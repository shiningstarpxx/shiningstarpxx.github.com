{"meta":{"title":"XStarX World","subtitle":null,"description":null,"author":"Pei, Xingxin","url":"http://shiningstarpxx.github.com","root":"/"},"pages":[{"title":"404","date":"2019-04-03T02:43:33.000Z","updated":"2019-04-03T02:43:33.185Z","comments":true,"path":"404/index.html","permalink":"http://shiningstarpxx.github.com/404/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-03T02:44:47.000Z","updated":"2019-04-03T02:44:47.018Z","comments":true,"path":"about/index.html","permalink":"http://shiningstarpxx.github.com/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-03T02:41:56.000Z","updated":"2019-04-03T02:43:20.987Z","comments":true,"path":"categories/index.html","permalink":"http://shiningstarpxx.github.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-03T02:43:28.000Z","updated":"2019-04-03T02:47:54.852Z","comments":true,"path":"tags/index.html","permalink":"http://shiningstarpxx.github.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"kafka 介绍","slug":"kafka-介绍","date":"2019-04-05T13:10:05.000Z","updated":"2019-04-06T03:25:19.233Z","comments":true,"path":"2019/04/05/kafka-介绍/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/05/kafka-介绍/","excerpt":"","text":"背景消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。常用的消息队列技术是 Message Queue。 从不同的角度来看kafka(MQ)A streaming platform has three key capabilities: (三个关键能力) Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system. (发布和订阅) Store streams of records in a fault-tolerant durable way. (持久化存储) Process streams of records as they occur. (顺序保证) Kafka is generally used for two broad classes of applications: (解决两大类问题) Building real-time streaming data pipelines that reliably get data between systems or applications — 实时数据流通道 Building real-time streaming applications that transform or react to the streams of data — 实时数据转换或者响应处理 kafka基本概念First a few concepts: Kafka is run as a cluster on one or more servers that can span multiple datacenters. — 可以跨数据中心 The Kafka cluster stores streams of records in categories called topics. — 聚类的数据流成为一个topic Each record consists of a key, a value, and a timestamp. — 每条记录都有key，value和timestamp Kafka has four core APIs: — 4 个核心api The Producer API allows an application to publish a stream of records to one or more Kafka topics. 生产者 The Consumer API allows an application to subscribe to one or more topics and process the stream of records produced to them. 消费者 The Streams API allows an application to act as a stream processor, consuming an input stream from one or more topics and producing an output stream to one or more output topics, effectively transforming the input streams to output streams. 流式api The Connector API allows building and running reusable producers or consumers that connect Kafka topics to existing applications or data systems. For example, a connector to a relational database might capture every change to a table. 连接者？ Kafka API图如下所示 Topics and LogsA topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it. 在广告业务中，比较典型的使用是，request是一个大的topic，还有广告相关曝光，点击日志等分别是不同的topic。 For each topic, the Kafka cluster maintains a partitioned log that looks like this: (一个topic会有多个partition，对于请求日志来说，因为太大了，所以一定有分片) Each partition is an ordered, immutable sequence of records that is continually appended to—a structured commit log. The records in the partitions are each assigned a sequential id number called the offset that uniquely identifies each record within the partition. 每一个分片里都是顺序的，不可修改的，这样做也是为了性能，update是一个非常耗时的操作. The Kafka cluster durably persists all published records—whether or not they have been consumed—using a configurable retention period. For example, if the retention policy is set to two days, then for the two days after a record is published, it is available for consumption, after which it will be discarded to free up space. Kafka’s performance is effectively constant with respect to data size so storing data for a long time is not a problem. kafka可以根据设置的时间做持久化存储，性能和数据大小也是常数关系，对数据增长不敏感。 In fact, the only metadata retained on a per-consumer basis is the offset or position of that consumer in the log. This offset is controlled by the consumer: normally a consumer will advance its offset linearly as it reads records, but, in fact, since the position is controlled by the consumer it can consume records in any order it likes. For example a consumer can reset to an older offset to reprocess data from the past or skip ahead to the most recent record and start consuming from “now”. 跟comsumer相关的只有metadata，并且可以由consumer随意修改控制 This combination of features means that Kafka consumers are very cheap—they can come and go without much impact on the cluster or on other consumers. For example, you can use our command line tools to “tail” the contents of any topic without changing what is consumed by any existing consumers. 这种相结合的设计（kafka维护metadata，consumer负责控制），可以说兼顾了灵活和高效。另外的一种设计方式，是meta data由consumer来存储和控制–RabbitMQ？ The partitions in the log serve several purposes. First, they allow the log to scale beyond a size that will fit on a single server. Each individual partition must fit on the servers that host it, but a topic may have many partitions so it can handle an arbitrary amount of data. Second they act as the unit of parallelism—more on that in a bit. partiion分区是为了增加topic的容量和吞吐量","categories":[],"tags":[{"name":"StreamingSystem, MQ","slug":"StreamingSystem-MQ","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem-MQ/"}]},{"title":"linux使用zsh","slug":"linux使用zsh","date":"2019-04-04T11:29:53.000Z","updated":"2019-04-04T11:35:59.373Z","comments":true,"path":"2019/04/04/linux使用zsh/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/04/linux使用zsh/","excerpt":"","text":"背景shell目前主流是/bin/bash, 但是配色真丑。业界里提供了很多更好的bash，比如叫zsh。 在mac上和linux上我都安装了zsh 1.安装zsh包1yum -y install zsh 2.切换默认shell为zsh1chsh -s /bin/zsh 3.重启服务器让修改的配置生效这个没什么好多说的，我习惯在web端控制台直接重启。 4.安装on my zshcurlsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;wgetsh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 实际上到这一步oh my zsh就已经安装完成了。 5. 最后调整theme使用ys主题","categories":[],"tags":[{"name":"linux, bash","slug":"linux-bash","permalink":"http://shiningstarpxx.github.com/tags/linux-bash/"}]},{"title":"Apache Kafka Installation on Mac using Homebrew","slug":"Apache-Kafka-Installation-on-Mac-using-Homebrew","date":"2019-04-03T14:08:08.000Z","updated":"2019-04-03T14:30:09.399Z","comments":true,"path":"2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/","excerpt":"","text":"背景学习大数据，离不开kafka，mac os上就得装一个。安装步骤如下 12$ brew cask install java$ brew install kafka 启动zookeeper1$ zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties 启动kafka server1$ kafka-server-start /usr/local/etc/kafka/server.properties 开始验证创建kafka topicA topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it. 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test Initialize Producer console1234kafka-console-producer --broker-list localhost:9092 --topic test&gt;send first message&gt;send second message&gt;wow it is working Initialize Consumer console1234kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginningsend first messagesend second messagewow it is working","categories":[],"tags":[{"name":"StreamingSystem, MQ","slug":"StreamingSystem-MQ","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem-MQ/"}]},{"title":"部署elk","slug":"部署elk","date":"2019-04-02T12:39:24.000Z","updated":"2019-04-03T02:50:54.795Z","comments":true,"path":"2019/04/02/部署elk/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/02/部署elk/","excerpt":"","text":"背景elk已经成为了业界的标准日志分析系统，这里在mac os上做了一些测试验证, 这里方便以后查询，把操作过程做了记录. Installing ElasticsearchNow that we’ve made sure our system and environment have the required pieces in place, we can begin with installing the stack’s components, starting with Elasticsearch: 12brew install elasticsearch &amp;&amp; brew info elasticsearchbrew services start elasticsearch Use your favorite browser to check that it is running correctly on localhost and the default port: http://localhost:9200 The output should look something like this: 1234567891011121314151617&#123; \"name\" : \"FH0SVRp\", \"cluster_name\" : \"elasticsearch_peixingxin\", \"cluster_uuid\" : \"7uVXslqeQ_al6pZA2p0AGQ\", \"version\" : &#123; \"number\" : \"6.7.0\", \"build_flavor\" : \"oss\", \"build_type\" : \"tar\", \"build_hash\" : \"8453f77\", \"build_date\" : \"2019-03-21T15:32:29.844721Z\", \"build_snapshot\" : false, \"lucene_version\" : \"7.7.0\", \"minimum_wire_compatibility_version\" : \"5.6.0\", \"minimum_index_compatibility_version\" : \"5.0.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; Installing LogstashYour next step is to install Logstash: 12brew install logstashbrew services start logstash Installing Kibana123brew install kibanabrew services start kibanabrew services list Open the Kibana configuration file: kibana.yml 1sudo vi /usr/local/etc/kibana/kibana.yml 12server.port: 5601elasticsearch.url: \"http://localhost:9200” If everything went well, open Kibana at http://localhost:5601/status. You should see something like this: Shipping some dataYou are ready to start sending data into Elasticsearch and enjoy all the goodness that the stack offers. To help you get started, here is an example of a Logstash pipeline sending syslog logs into the stack. First, you will need to create a new Logstash configuration file: 同时要在配置文件中增加该路径 1sudo vim //user/local/etc/logstash/syslog.conf Enter the following configuration: 12345678910111213141516171819202122232425262728input &#123; file &#123; path =&gt; [ \"/var/log/*.log\", \"/var/log/messages\", \"/var/log/syslog\" ] type =&gt; \"syslog\" &#125;&#125; filter &#123; if [type] == \"syslog\" &#123; grok &#123; match =&gt; &#123; \"message\" =&gt; \"%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125; %&#123;SYSLOGHOST:syslog_hostname&#125; %&#123;DATA:syslog_program&#125;(?:\\[%&#123;POSINT:syslog_pid&#125;\\])?: %&#123;GREEDYDATA:syslog_message&#125;\" &#125; add_field =&gt; [ \"received_at\", \"%&#123;@timestamp&#125;\" ] add_field =&gt; [ \"received_from\", \"%&#123;host&#125;\" ] &#125; syslog_pri &#123; &#125; date &#123; match =&gt; [ \"syslog_timestamp\", \"MMM d HH:mm:ss\", \"MMM dd HH:mm:ss\" ] &#125; &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; [\"127.0.0.1:9200\"] index =&gt; \"syslog-demo\" &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 1brew services restart logstash In the Management tab in Kibana, you should see a newly created “syslog-demo” index created by the new Logstash pipeline. Reference网上比较好的文档","categories":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/categories/StreamingSystem/"}],"tags":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem/"},{"name":"elk","slug":"elk","permalink":"http://shiningstarpxx.github.com/tags/elk/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-28T00:39:58.000Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2017/10/28/hello-world/","link":"","permalink":"http://shiningstarpxx.github.com/2017/10/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}