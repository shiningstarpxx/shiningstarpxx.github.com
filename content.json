{"meta":{"title":"XStarX World","subtitle":null,"description":null,"author":"Pei, Xingxin","url":"http://shiningstarpxx.github.com","root":"/"},"pages":[{"title":"404","date":"2019-04-03T02:43:33.000Z","updated":"2019-04-03T02:43:33.185Z","comments":true,"path":"404/index.html","permalink":"http://shiningstarpxx.github.com/404/index.html","excerpt":"","text":""},{"title":"tags","date":"2019-04-03T02:43:28.000Z","updated":"2019-04-03T02:47:54.852Z","comments":true,"path":"tags/index.html","permalink":"http://shiningstarpxx.github.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2019-04-03T02:41:56.000Z","updated":"2019-04-03T02:43:20.987Z","comments":true,"path":"categories/index.html","permalink":"http://shiningstarpxx.github.com/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-04-03T02:44:47.000Z","updated":"2019-04-03T02:44:47.018Z","comments":true,"path":"about/index.html","permalink":"http://shiningstarpxx.github.com/about/index.html","excerpt":"","text":""}],"posts":[{"title":"kafka-介绍-2","slug":"kafka-介绍-2","date":"2019-04-06T07:12:10.000Z","updated":"2019-04-06T09:03:16.984Z","comments":true,"path":"2019/04/06/kafka-介绍-2/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/06/kafka-介绍-2/","excerpt":"","text":"上文回顾上一篇介绍了kafka基本的组成和功能，同时介绍了生产-消费的过程，以及简单描述了kafka的replication等等概念性的。这一篇还是概念性的，结合kafka官方文档学习。 Multi-tenancy 多租约You can deploy Kafka as a multi-tenant solution. Multi-tenancy is enabled by configuring which topics can produce or consume data. There is also operations support for quotas. Administrators can define and enforce quotas on requests to control the broker resources that are used by clients. For more information, see the security documentation. 多组约问题放到后面再深入研究 @TODO GaranteesAt a high-level Kafka gives the following guarantees: kafka保证下面的 Messages sent by a producer to a particular topic partition will be appended in the order they are sent. That is, if a record M1 is sent by the same producer as a record M2, and M1 is sent first, then M1 will have a lower offset than M2 and appear earlier in the log. 在同一个topic内，一个生产者产生的record有序. A consumer instance sees records in the order they are stored in the log. 消费者看到是有序的 For a topic with replication factor N, we will tolerate up to N-1 server failures without losing any records committed to the log. 如果replication的参数是N，那么最多容忍N-1的服务失败但是不丢数据 More details on these guarantees are given in the design section of the documentation. KafKa As a messaging System kafka作为消息系统How does Kafka’s notion of streams compare to a traditional enterprise messaging system? Kafka 与传统的消息系统的对比 Messaging traditionally has two models: queuing and publish-subscribe. In a queue, a pool of consumers may read from a server and each record goes to one of them; in publish-subscribe the record is broadcast to all consumers. Each of these two models has a strength and a weakness. The strength of queuing is that it allows you to divide up the processing of data over multiple consumer instances, which lets you scale your processing. Unfortunately, queues aren’t multi-subscriber—once one process reads the data it’s gone. Publish-subscribe allows you broadcast data to multiple processes, but has no way of scaling processing since every message goes to every subscriber. 传统的消息有两种模型：队列和“发布-订阅”。在queue种，消费池可以从一个server上读，每个记录会被一个消费者消费；在发布-订阅模式，记录广播给所有的消费者。 两种模型各有优劣。 queue的优点是可以让记录在不同的消费者之间分配，可以scale。但是不幸的是，queue不能多订阅者，数据一读就消失了。发布-订阅可以广播消息到不同进程，但是在不同进程间无法scale，因为每个消息都会发给不同进程。 The consumer group concept in Kafka generalizes these two concepts. As with a queue the consumer group allows you to divide up processing over a collection of processes (the members of the consumer group). As with publish-subscribe, Kafka allows you to broadcast messages to multiple consumer groups. Kafka 融合了这两个概念，消费组里可以共享一组消息，不同组之间消息是独立的。 The advantage of Kafka’s model is that every topic has both these properties—it can scale processing and is also multi-subscriber—there is no need to choose one or the other. kafka模型保证了process可以scale，同时支持多订阅者。 Kafka has stronger ordering guarantees than a traditional messaging system, too. kafka保证了更强的顺序性 A traditional queue retains records in-order on the server, and if multiple consumers consume from the queue then the server hands out records in the order they are stored. However, although the server hands out records in order, the records are delivered asynchronously to consumers, so they may arrive out of order on different consumers. This effectively means the ordering of the records is lost in the presence of parallel consumption. Messaging systems often work around this by having a notion of “exclusive consumer” that allows only one process to consume from a queue, but of course this means that there is no parallelism in processing. queue的模型保证了server存储数据的顺序性，但是不能保证消费者的顺序性。 Kafka does it better. By having a notion of parallelism—the partition—within the topics, Kafka is able to provide both ordering guarantees and load balancing over a pool of consumer processes. This is achieved by assigning the partitions in the topic to the consumers in the consumer group so that each partition is consumed by exactly one consumer in the group. By doing this we ensure that the consumer is the only reader of that partition and consumes the data in order. Since there are many partitions this still balances the load over many consumer instances. Note however that there cannot be more consumer instances in a consumer group than partitions. kafka同时保证了顺序性和消费组内的平衡。在一个消费组内，kafka只要每个partition分配一个消费者就可以保证顺序性，和scale。但是kafka消费组内最大的consumer数量就是分片的数量 Kafka作为存储系统Any message queue that allows publishing messages decoupled from consuming them is effectively acting as a storage system for the in-flight messages. What is different about Kafka is that it is a very good storage system. Data written to Kafka is written to disk and replicated for fault-tolerance. Kafka allows producers to wait on acknowledgement so that a write isn’t considered complete until it is fully replicated and guaranteed to persist even if the server written to fails. kafka写数据为了fault-tolerance做了replication The disk structures Kafka uses scale well—Kafka will perform the same whether you have 50 KB or 50 TB of persistent data on the server. kafka对disk也做了scale考虑 As a result of taking storage seriously and allowing the clients to control their read position, you can think of Kafka as a kind of special purpose distributed filesystem dedicated to high-performance, low-latency commit log storage, replication, and propagation. kafka可以认为是为了特定目的的分布式文件系统，满足high-performance，low-latency, commit log storage, replication and propagation. For details about the Kafka’s commit log storage and replication design, please read this page. Kafka 作为streaming systemIt isn’t enough to just read, write, and store streams of data, the purpose is to enable real-time processing of streams. In Kafka a stream processor is anything that takes continual streams of data from input topics, performs some processing on this input, and produces continual streams of data to output topics. 针对流式系统 For example, a retail application might take in input streams of sales and shipments, and output a stream of reorders and price adjustments computed off this data. 比如sales，货运信息， 会使订单调整&amp;price调整 . It is possible to do simple processing directly using the producer and consumer APIs. However for more complex transformations Kafka provides a fully integrated Streams API. This allows building applications that do non-trivial processing that compute aggregations off of streams or join streams together. This facility helps solve the hard problems this type of application faces: handling out-of-order data, reprocessing input as code changes, performing stateful computations, etc. 解决乱序数据，代码更新后重新计算，做状态计算等等能力 The streams API builds on the core primitives Kafka provides: it uses the producer and consumer APIs for input, uses Kafka for stateful storage, and uses the same group mechanism for fault tolerance among the stream processor instances. kafka综合能力This combination of messaging, storage, and stream processing may seem unusual but it is essential to Kafka’s role as a streaming platform. 虽然支持消息，存储，流处理，但是核心还是流处理平台 A distributed file system like HDFS allows storing static files for batch processing. Effectively a system like this allows storing and processing historical data from the past. 分布式文件hdfs支持处理历史数据-batch A traditional enterprise messaging system allows processing future messages that will arrive after you subscribe. Applications built in this way process future data as it arrives. 传统企业消息系统允许处理随时订阅，支持任何时候消息到达。 Kafka combines both of these capabilities, and the combination is critical both for Kafka usage as a platform for streaming applications as well as for streaming data pipelines. kafka既是streaming application的platform又是streaming data的pipelines By combining storage and low-latency subscriptions, streaming applications can treat both past and future data the same way. That is a single application can process historical, stored data but rather than ending when it reaches the last record it can keep processing as future data arrives. This is a generalized notion of stream processing that subsumes batch processing as well as message-driven applications. 结合了low-latency和streaming application，可以统一处理过去和未来的数据，也就是说可以作为batch处理也可以作为message-driven应用。 Likewise for streaming data pipelines the combination of subscription to real-time events make it possible to use Kafka for very low-latency pipelines; but the ability to store data reliably make it possible to use it for critical data where the delivery of data must be guaranteed or for integration with offline systems that load data only periodically or may go down for extended periods of time for maintenance. The stream processing facilities make it possible to transform data as it arrives. 同时是低时延，还支持容灾存储关键数据 For more information on the guarantees, APIs, and capabilities Kafka provides see the rest of the documentation. Reference 参考 Apache Kafka 首页，了解最全面的 Apache Kafka 知识","categories":[],"tags":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem/"},{"name":"MQ","slug":"MQ","permalink":"http://shiningstarpxx.github.com/tags/MQ/"}]},{"title":"kafka 介绍 — 1","slug":"kafka-介绍","date":"2019-04-05T13:10:05.000Z","updated":"2019-04-06T09:03:34.019Z","comments":true,"path":"2019/04/05/kafka-介绍/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/05/kafka-介绍/","excerpt":"","text":"背景消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。常用的消息队列技术是 Message Queue。 从不同的角度来看kafka(MQ)A streaming platform has three key capabilities: (三个关键能力) Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system. (发布和订阅) Store streams of records in a fault-tolerant durable way. (持久化存储) Process streams of records as they occur. (顺序保证) Kafka is generally used for two broad classes of applications: (解决两大类问题) Building real-time streaming data pipelines that reliably get data between systems or applications — 实时数据流通道 Building real-time streaming applications that transform or react to the streams of data — 实时数据转换或者响应处理 kafka基本概念First a few concepts: Kafka is run as a cluster on one or more servers that can span multiple datacenters. — 可以跨数据中心 The Kafka cluster stores streams of records in categories called topics. — 聚类的数据流成为一个topic Each record consists of a key, a value, and a timestamp. — 每条记录都有key，value和timestamp Kafka has four core APIs: — 4 个核心api The Producer API allows an application to publish a stream of records to one or more Kafka topics. 生产者 The Consumer API allows an application to subscribe to one or more topics and process the stream of records produced to them. 消费者 The Streams API allows an application to act as a stream processor, consuming an input stream from one or more topics and producing an output stream to one or more output topics, effectively transforming the input streams to output streams. 流式api The Connector API allows building and running reusable producers or consumers that connect Kafka topics to existing applications or data systems. For example, a connector to a relational database might capture every change to a table. 连接者？ Kafka API图如下所示 Topics and LogsA topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it. 在广告业务中，比较典型的使用是，request是一个大的topic，还有广告相关曝光，点击日志等分别是不同的topic。 For each topic, the Kafka cluster maintains a partitioned log that looks like this: (一个topic会有多个partition，对于请求日志来说，因为太大了，所以一定有分片) Each partition is an ordered, immutable sequence of records that is continually appended to—a structured commit log. The records in the partitions are each assigned a sequential id number called the offset that uniquely identifies each record within the partition. 每一个分片里都是顺序的，不可修改的，这样做也是为了性能，update是一个非常耗时的操作. The Kafka cluster durably persists all published records—whether or not they have been consumed—using a configurable retention period. For example, if the retention policy is set to two days, then for the two days after a record is published, it is available for consumption, after which it will be discarded to free up space. Kafka’s performance is effectively constant with respect to data size so storing data for a long time is not a problem. kafka可以根据设置的时间做持久化存储，性能和数据大小也是常数关系，对数据增长不敏感。 In fact, the only metadata retained on a per-consumer basis is the offset or position of that consumer in the log. This offset is controlled by the consumer: normally a consumer will advance its offset linearly as it reads records, but, in fact, since the position is controlled by the consumer it can consume records in any order it likes. For example a consumer can reset to an older offset to reprocess data from the past or skip ahead to the most recent record and start consuming from “now”. 跟comsumer相关的只有metadata，并且可以由consumer随意修改控制 This combination of features means that Kafka consumers are very cheap—they can come and go without much impact on the cluster or on other consumers. For example, you can use our command line tools to “tail” the contents of any topic without changing what is consumed by any existing consumers. 这种相结合的设计（kafka维护metadata，consumer负责控制），可以说兼顾了灵活和高效。另外的一种设计方式，是meta data由consumer来存储和控制–RabbitMQ？ The partitions in the log serve several purposes. First, they allow the log to scale beyond a size that will fit on a single server. Each individual partition must fit on the servers that host it, but a topic may have many partitions so it can handle an arbitrary amount of data. Second they act as the unit of parallelism—more on that in a bit. partiion分区是为了增加topic的容量和吞吐量 Distribution分布式The partitions of the log are distributed over the servers in the Kafka cluster with each server handling data and requests for a share of the partitions. Each partition is replicated across a configurable number of servers for fault tolerance. log的分片是分布式的，replicated数量也是根据配置来设置 Each partition has one server which acts as the “leader” and zero or more servers which act as “followers”. The leader handles all read and write requests for the partition while the followers passively replicate the leader. If the leader fails, one of the followers will automatically become the new leader. Each server acts as a leader for some of its partitions and a follower for others so load is well balanced within the cluster. 每个分片一定会有一个leader，0个或者多个followers。leader负责读写，followers是负责replicate。如果leader挂了，一个follower会自动成为新的leader。每个服务可以做几个分片的leader，也可以做其他几个分片的follower，来实现load balance。(这也是因为replicate决定了一个server会有多个partition，作为容灾) Geo-ReplicationKafka MirrorMaker provides geo-replication support for your clusters. With MirrorMaker, messages are replicated across multiple datacenters or cloud regions. You can use this in active/passive scenarios for backup and recovery; or in active/active scenarios to place data closer to your users, or support data locality requirements. 可以跨地域备份，主动&amp;被动都可以 Producers 生产者Producers publish data to the topics of their choice. The producer is responsible for choosing which record to assign to which partition within the topic. This can be done in a round-robin fashion simply to balance load or it can be done according to some semantic partition function (say based on some key in the record). More on the use of partitioning in a second! 生产者要保证均匀-平衡的写入同一个topic的分片中 Consumers 消费者Consumers label themselves with a consumer group name, and each record published to a topic is delivered to one consumer instance within each subscribing consumer group. Consumer instances can be in separate processes or on separate machines. 消费者有消费组的概念，在一个消费组内，一个记录只能被一个消费者消费。消费者实例可以是不同的进程，也可以在不同的机器上 If all the consumer instances have the same consumer group, then the records will effectively be load balanced over the consumer instances. 同一个组内的消费者会balanced的消费records If all the consumer instances have different consumer groups, then each record will be broadcast to all the consumer processes. 每个record会广播给不同消费者组 A two server Kafka cluster hosting four partitions (P0-P3) with two consumer groups. Consumer group A has two consumer instances and group B has four. 如上图所示，4个分片，两个消费组 More commonly, however, we have found that topics have a small number of consumer groups, one for each “logical subscriber”. Each group is composed of many consumer instances for scalability and fault tolerance. This is nothing more than publish-subscribe semantics where the subscriber is a cluster of consumers instead of a single process. 通常我们观察到，每个话题通常是有少数几个消费组，每个表示一个逻辑上的订阅。每个组由几个消费实例用于scalability和容错。这个语义也是包含发布-订阅 The way consumption is implemented in Kafka is by dividing up the partitions in the log over the consumer instances so that each instance is the exclusive consumer of a “fair share” of partitions at any point in time. This process of maintaining membership in the group is handled by the Kafka protocol dynamically. If new instances join the group they will take over some partitions from other members of the group; if an instance dies, its partitions will be distributed to the remaining instances. kafka的实现是基于log分配给消费实例，这样每个实例可以在任意时间点”公平”的消费。消费实例的平衡由kafka内部实现。如果新的加入，会从其他人身上分担一些，如果一个挂掉，会分给其他人。—看起来很像是一致性哈希保证的。 Kafka only provides a total order over records within a partition, not between different partitions in a topic. Per-partition ordering combined with the ability to partition data by key is sufficient for most applications. However, if you require a total order over records this can be achieved with a topic that has only one partition, though this will mean only one consumer process per consumer group. kafka只能保证同一个topic的同一个partition内有序。如果需要topic强有序，只能有一个分片，这样会导致只能有一个消费实例在一个消费组里。 Reference 参考 Apache Kafka 首页，了解最全面的 Apache Kafka 知识。 Apache kafka 工作原理介绍","categories":[],"tags":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem/"},{"name":"MQ","slug":"MQ","permalink":"http://shiningstarpxx.github.com/tags/MQ/"}]},{"title":"linux使用zsh","slug":"linux使用zsh","date":"2019-04-04T11:29:53.000Z","updated":"2019-04-04T11:35:59.373Z","comments":true,"path":"2019/04/04/linux使用zsh/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/04/linux使用zsh/","excerpt":"","text":"背景shell目前主流是/bin/bash, 但是配色真丑。业界里提供了很多更好的bash，比如叫zsh。 在mac上和linux上我都安装了zsh 1.安装zsh包1yum -y install zsh 2.切换默认shell为zsh1chsh -s /bin/zsh 3.重启服务器让修改的配置生效这个没什么好多说的，我习惯在web端控制台直接重启。 4.安装on my zshcurlsh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;wgetsh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot; 实际上到这一步oh my zsh就已经安装完成了。 5. 最后调整theme使用ys主题","categories":[],"tags":[{"name":"linux, bash","slug":"linux-bash","permalink":"http://shiningstarpxx.github.com/tags/linux-bash/"}]},{"title":"Apache Kafka Installation on Mac using Homebrew","slug":"Apache-Kafka-Installation-on-Mac-using-Homebrew","date":"2019-04-03T14:08:08.000Z","updated":"2019-04-10T02:15:00.116Z","comments":true,"path":"2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/","excerpt":"","text":"背景学习大数据，离不开kafka，mac os上就得装一个。安装步骤如下 12$ brew cask install java$ brew install kafka 启动zookeeper1$ zookeeper-server-start /usr/local/etc/kafka/zookeeper.properties 启动kafka server1$ kafka-server-start /usr/local/etc/kafka/server.properties 开始验证创建kafka topicA topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it. 1kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic test Initialize Producer console1234kafka-console-producer --broker-list localhost:9092 --topic test&gt;send first message&gt;send second message&gt;wow it is working Initialize Consumer console1234kafka-console-consumer --bootstrap-server localhost:9092 --topic test --from-beginningsend first messagesend second messagewow it is working 列出所有的topic1$ kafka-topics --list --zookeeper localhost:2181 查看topic的状态123$ kafka-topics --describe --zookeeper localhost:2181 --topic testTopic:test PartitionCount:1 ReplicationFactor:1 Configs: Topic: test Partition: 0 Leader: 0 Replicas: 0 Isr: 0 “leader” is the node responsible for all reads and writes for the given partition. Each node will be the leader for a randomly selected portion of the partitions. “replicas” is the list of nodes that replicate the log for this partition regardless of whether they are the leader or even if they are currently alive. “isr” is the set of “in-sync” replicas. This is the subset of the replicas list that is currently alive and caught-up to the leader. 尝试做多个备份1234$ kafka-topics --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic multi-testError while executing topic command : Replication factor: 3 larger than available brokers: 1.[2019-04-10 10:04:28,763] ERROR org.apache.kafka.common.errors.InvalidReplicationFactorException: Replication factor: 3 larger than available brokers: 1. (kafka.admin.TopicCommand$) 发现报错，原因是我们起的broker只有一个，需要多起几个broker","categories":[],"tags":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem/"},{"name":"MQ","slug":"MQ","permalink":"http://shiningstarpxx.github.com/tags/MQ/"}]},{"title":"部署elk","slug":"部署elk","date":"2019-04-02T12:39:24.000Z","updated":"2019-04-03T02:50:54.795Z","comments":true,"path":"2019/04/02/部署elk/","link":"","permalink":"http://shiningstarpxx.github.com/2019/04/02/部署elk/","excerpt":"","text":"背景elk已经成为了业界的标准日志分析系统，这里在mac os上做了一些测试验证, 这里方便以后查询，把操作过程做了记录. Installing ElasticsearchNow that we’ve made sure our system and environment have the required pieces in place, we can begin with installing the stack’s components, starting with Elasticsearch: 12brew install elasticsearch &amp;&amp; brew info elasticsearchbrew services start elasticsearch Use your favorite browser to check that it is running correctly on localhost and the default port: http://localhost:9200 The output should look something like this: 1234567891011121314151617&#123; \"name\" : \"FH0SVRp\", \"cluster_name\" : \"elasticsearch_peixingxin\", \"cluster_uuid\" : \"7uVXslqeQ_al6pZA2p0AGQ\", \"version\" : &#123; \"number\" : \"6.7.0\", \"build_flavor\" : \"oss\", \"build_type\" : \"tar\", \"build_hash\" : \"8453f77\", \"build_date\" : \"2019-03-21T15:32:29.844721Z\", \"build_snapshot\" : false, \"lucene_version\" : \"7.7.0\", \"minimum_wire_compatibility_version\" : \"5.6.0\", \"minimum_index_compatibility_version\" : \"5.0.0\" &#125;, \"tagline\" : \"You Know, for Search\"&#125; Installing LogstashYour next step is to install Logstash: 12brew install logstashbrew services start logstash Installing Kibana123brew install kibanabrew services start kibanabrew services list Open the Kibana configuration file: kibana.yml 1sudo vi /usr/local/etc/kibana/kibana.yml 12server.port: 5601elasticsearch.url: \"http://localhost:9200” If everything went well, open Kibana at http://localhost:5601/status. You should see something like this: Shipping some dataYou are ready to start sending data into Elasticsearch and enjoy all the goodness that the stack offers. To help you get started, here is an example of a Logstash pipeline sending syslog logs into the stack. First, you will need to create a new Logstash configuration file: 同时要在配置文件中增加该路径 1sudo vim //user/local/etc/logstash/syslog.conf Enter the following configuration: 12345678910111213141516171819202122232425262728input &#123; file &#123; path =&gt; [ \"/var/log/*.log\", \"/var/log/messages\", \"/var/log/syslog\" ] type =&gt; \"syslog\" &#125;&#125; filter &#123; if [type] == \"syslog\" &#123; grok &#123; match =&gt; &#123; \"message\" =&gt; \"%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125; %&#123;SYSLOGHOST:syslog_hostname&#125; %&#123;DATA:syslog_program&#125;(?:\\[%&#123;POSINT:syslog_pid&#125;\\])?: %&#123;GREEDYDATA:syslog_message&#125;\" &#125; add_field =&gt; [ \"received_at\", \"%&#123;@timestamp&#125;\" ] add_field =&gt; [ \"received_from\", \"%&#123;host&#125;\" ] &#125; syslog_pri &#123; &#125; date &#123; match =&gt; [ \"syslog_timestamp\", \"MMM d HH:mm:ss\", \"MMM dd HH:mm:ss\" ] &#125; &#125;&#125; output &#123; elasticsearch &#123; hosts =&gt; [\"127.0.0.1:9200\"] index =&gt; \"syslog-demo\" &#125; stdout &#123; codec =&gt; rubydebug &#125;&#125; 1brew services restart logstash In the Management tab in Kibana, you should see a newly created “syslog-demo” index created by the new Logstash pipeline. Reference网上比较好的文档","categories":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/categories/StreamingSystem/"}],"tags":[{"name":"StreamingSystem","slug":"StreamingSystem","permalink":"http://shiningstarpxx.github.com/tags/StreamingSystem/"},{"name":"elk","slug":"elk","permalink":"http://shiningstarpxx.github.com/tags/elk/"}]},{"title":"Hello World","slug":"hello-world","date":"2017-10-28T00:39:58.000Z","updated":"2017-10-28T00:39:58.000Z","comments":true,"path":"2017/10/28/hello-world/","link":"","permalink":"http://shiningstarpxx.github.com/2017/10/28/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}]}