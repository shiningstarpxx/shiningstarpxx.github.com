<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>XStarX World</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://shiningstarpxx.github.com/"/>
  <updated>2020-04-08T07:10:19.080Z</updated>
  <id>http://shiningstarpxx.github.com/</id>
  
  <author>
    <name>Pei, Xingxin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>flink-下载编译</title>
    <link href="http://shiningstarpxx.github.com/2020/04/08/flink-%E4%B8%8B%E8%BD%BD%E7%BC%96%E8%AF%91/"/>
    <id>http://shiningstarpxx.github.com/2020/04/08/flink-下载编译/</id>
    <published>2020-04-08T07:09:22.000Z</published>
    <updated>2020-04-08T07:10:19.080Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Apache Flink官网下载安装包不能支持CDH，需要编译后进行安装，参照网上很多资料，尝试了多天，终于成功，供大家参考。</span><br></pre></td></tr></table></figure><p>1、环境<br>Jdk 1.8、centos7.6、Maven 3.6.2和Scala-2.12</p><p>2、源码和CDH 版本<br>Flink 1.10.0 、 CDH 6.3.1(Hadoop 3.0.0)</p><p>3、配置maven源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirrors&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">              &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">              &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;central&lt;/id&gt;</span><br><span class="line">              &lt;name&gt;Maven Repository Switchboard&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://repo1.maven.org/maven2/&lt;/url&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;repo2&lt;/id&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">              &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;ibiblio&lt;/id&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">              &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://mirrors.ibiblio.org/pub/mirrors/maven2/&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;jboss-public-repository-group&lt;/id&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">              &lt;name&gt;JBoss Public Repository Group&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://repository.jboss.org/nexus/content/groups/public&lt;/url&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;google-maven-central&lt;/id&gt;</span><br><span class="line">              &lt;name&gt;Google Maven Central&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;https://maven-central.storage.googleapis.com</span><br><span class="line">              &lt;/url&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">      &lt;!-- 中央仓库在中国的镜像 --&gt;</span><br><span class="line">      &lt;mirror&gt;</span><br><span class="line">              &lt;id&gt;maven.net.cn&lt;/id&gt;</span><br><span class="line">              &lt;name&gt;oneof the central mirrors in china&lt;/name&gt;</span><br><span class="line">              &lt;url&gt;http://maven.net.cn/content/groups/public/&lt;/url&gt;</span><br><span class="line">              &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;</span><br><span class="line">      &lt;/mirror&gt;</span><br><span class="line">&lt;/mirrors&gt;</span><br></pre></td></tr></table></figure><p>4、下载依赖的 flink-shaded 源码<br>不同的 Flink 版本使用的 Flink-shaded不同，1.10 版本使用 10.0<br><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-shaded-10.0/flink-shaded-10.0-src.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-shaded-10.0/flink-shaded-10.0-src.tgz</a></p><p>解压后，在 pom.xml 中，添加如下，加入到标签中</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">        &lt;id&gt;vendor-repos&lt;/id&gt;</span><br><span class="line">        &lt;activation&gt;</span><br><span class="line">                &lt;property&gt;</span><br><span class="line">                        &lt;name&gt;vendor-repos&lt;/name&gt;</span><br><span class="line">                &lt;/property&gt;</span><br><span class="line">        &lt;/activation&gt;</span><br><span class="line">        &lt;!-- Add vendor maven repositories --&gt;</span><br><span class="line">        &lt;repositories&gt;</span><br><span class="line">                &lt;!-- Cloudera --&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                        &lt;id&gt;cloudera-releases&lt;/id&gt;</span><br><span class="line">                        &lt;url&gt;https://repository.cloudera.com/artifactory/cloudera-repos&lt;/url&gt;</span><br><span class="line">                        &lt;releases&gt;</span><br><span class="line">                                &lt;enabled&gt;true&lt;/enabled&gt;</span><br><span class="line">                        &lt;/releases&gt;</span><br><span class="line">                        &lt;snapshots&gt;</span><br><span class="line">                                &lt;enabled&gt;false&lt;/enabled&gt;</span><br><span class="line">                        &lt;/snapshots&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">                &lt;!-- Hortonworks --&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                        &lt;id&gt;HDPReleases&lt;/id&gt;</span><br><span class="line">                        &lt;name&gt;HDP Releases&lt;/name&gt;</span><br><span class="line">                        &lt;url&gt;https://repo.hortonworks.com/content/repositories/releases/&lt;/url&gt;</span><br><span class="line">                        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class="line">                        &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                        &lt;id&gt;HortonworksJettyHadoop&lt;/id&gt;</span><br><span class="line">                        &lt;name&gt;HDP Jetty&lt;/name&gt;</span><br><span class="line">                        &lt;url&gt;https://repo.hortonworks.com/content/repositories/jetty-hadoop&lt;/url&gt;</span><br><span class="line">                        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class="line">                        &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">                &lt;!-- MapR --&gt;</span><br><span class="line">                &lt;repository&gt;</span><br><span class="line">                        &lt;id&gt;mapr-releases&lt;/id&gt;</span><br><span class="line">                        &lt;url&gt;https://repository.mapr.com/maven/&lt;/url&gt;</span><br><span class="line">                        &lt;snapshots&gt;&lt;enabled&gt;false&lt;/enabled&gt;&lt;/snapshots&gt;</span><br><span class="line">                        &lt;releases&gt;&lt;enabled&gt;true&lt;/enabled&gt;&lt;/releases&gt;</span><br><span class="line">                &lt;/repository&gt;</span><br><span class="line">        &lt;/repositories&gt;</span><br><span class="line">&lt;/profile&gt;</span><br></pre></td></tr></table></figure><p>编译对应的 flink-shaded 版本</p><p>$ mvn -T2C clean install -DskipTests -Pvendor-repos -Dhadoop.version=3.0.0-cdh6.3.1 -Dscala-2.12 -Drat.skip=true</p><p>(2)下载 Apache Flink 1.10.0</p><p><a href="https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.10.0/flink-1.10.0-src.tgz" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/apache/flink/flink-1.10.0/flink-1.10.0-src.tgz</a></p><p>(3)解压编译 Flink 源码</p><p>$mvn clean install -DskipTests -Dfast -Drat.skip=true -Dhaoop.version=3.0.0-cdh6.3.1 -Pvendor-repos -Dinclude-hadoop -Dscala-2.12 -T2C<br><img src="https://img-blog.csdnimg.cn/20200228174603190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21odGM1MDUy,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p><p>(5)提取出 flink-1.10.0 二进制包即可<br>目录地址：<br>flink-1.10.0/flink-dist/target/flink-1.10.0-bin</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span cla
      
    
    </summary>
    
    
      <category term="flink" scheme="http://shiningstarpxx.github.com/tags/flink/"/>
    
  </entry>
  
  <entry>
    <title>mac os查看占用端口的程序</title>
    <link href="http://shiningstarpxx.github.com/2020/02/04/mac-os%E6%9F%A5%E7%9C%8B%E5%8D%A0%E7%94%A8%E7%AB%AF%E5%8F%A3%E7%9A%84%E7%A8%8B%E5%BA%8F/"/>
    <id>http://shiningstarpxx.github.com/2020/02/04/mac-os查看占用端口的程序/</id>
    <published>2020-02-04T02:07:36.000Z</published>
    <updated>2020-02-04T02:07:36.749Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>kafka use</title>
    <link href="http://shiningstarpxx.github.com/2020/02/03/kafka-use/"/>
    <id>http://shiningstarpxx.github.com/2020/02/03/kafka-use/</id>
    <published>2020-02-03T07:26:32.000Z</published>
    <updated>2020-02-05T08:16:02.325Z</updated>
    
    <content type="html"><![CDATA[<p>在mac上安装kafka很简单，直接brew install 即可。安装完之后启动，参照brew的提示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># To have launchd start kafka now and restart at login:</span></span><br><span class="line">brew services start kafka</span><br><span class="line"><span class="comment"># Or, if you don't want/need a background service you can just run:</span></span><br><span class="line">zookeeper-server-start /usr/<span class="built_in">local</span>/etc/kafka/zookeeper.properties &amp; kafka-server-start /usr/<span class="built_in">local</span>/etc/kafka/server.properties</span><br></pre></td></tr></table></figure><p>稳妥点，可以分别执行上面的命令来判断服务是否能正常启动，如果不能，大概率是之前安装过，有些过期的文件，可以考虑进入到目录删除。</p><p>重要的一步是需要修改一个配置文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /usr/<span class="built_in">local</span>/etc/kafka/server.properties</span><br></pre></td></tr></table></figure><p>然后在下面的后面修改一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#listeners=PLAINTEXT://:9092</span><br><span class="line">listeners=PLAINTEXT://localhost:9092</span><br></pre></td></tr></table></figure><p>服务正常启动后就可以进入下面的环节了。</p><h5 id="创建Topic"><a href="#创建Topic" class="headerlink" title="创建Topic"></a>创建Topic</h5><p>执行下面的命令</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><p>显示的log 如下</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">542</span>] INFO [ReplicaFetcherManager on broker <span class="number">0</span>] Removed fetcher <span class="keyword">for</span> partitions Set(test-<span class="number">0</span>) (kafka<span class="variable">.server</span><span class="variable">.ReplicaFetcherManager</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">623</span>] INFO [Log partition=test-<span class="number">0</span>, dir=/usr/<span class="keyword">local</span>/<span class="keyword">var</span>/lib/kafka-logs] Loading producer state till offset <span class="number">0</span> <span class="keyword">with</span> message format version <span class="number">2</span> (kafka<span class="variable">.log</span><span class="variable">.Log</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">628</span>] INFO [Log partition=test-<span class="number">0</span>, dir=/usr/<span class="keyword">local</span>/<span class="keyword">var</span>/lib/kafka-logs] Completed load of log <span class="keyword">with</span> <span class="number">1</span> segments, log start offset <span class="number">0</span> <span class="keyword">and</span> log <span class="keyword">end</span> offset <span class="number">0</span> in <span class="number">44</span> ms (kafka<span class="variable">.log</span><span class="variable">.Log</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">630</span>] INFO Created log <span class="keyword">for</span> partition test-<span class="number">0</span> in /usr/<span class="keyword">local</span>/<span class="keyword">var</span>/lib/kafka-logs/test-<span class="number">0</span> <span class="keyword">with</span> properties &#123;compression<span class="variable">.type</span> -&gt; producer, message<span class="variable">.downconversion</span><span class="variable">.enable</span> -&gt; true, min<span class="variable">.insync</span><span class="variable">.replicas</span> -&gt; <span class="number">1</span>, segment<span class="variable">.jitter</span><span class="variable">.ms</span> -&gt; <span class="number">0</span>, cleanup<span class="variable">.policy</span> -&gt; [delete], flush<span class="variable">.ms</span> -&gt; <span class="number">9223372036854775807</span>, segment<span class="variable">.bytes</span> -&gt; <span class="number">1073741824</span>, retention<span class="variable">.ms</span> -&gt; <span class="number">604800000</span>, flush<span class="variable">.messages</span> -&gt; <span class="number">9223372036854775807</span>, message<span class="variable">.format</span><span class="variable">.version</span> -&gt; <span class="number">2</span><span class="variable">.4</span>-IV1, file<span class="variable">.delete</span><span class="variable">.delay</span><span class="variable">.ms</span> -&gt; <span class="number">60000</span>, max<span class="variable">.compaction</span><span class="variable">.lag</span><span class="variable">.ms</span> -&gt; <span class="number">9223372036854775807</span>, max<span class="variable">.message</span><span class="variable">.bytes</span> -&gt; <span class="number">1000012</span>, min<span class="variable">.compaction</span><span class="variable">.lag</span><span class="variable">.ms</span> -&gt; <span class="number">0</span>, message<span class="variable">.timestamp</span><span class="variable">.type</span> -&gt; CreateTime, preallocate -&gt; false, min<span class="variable">.cleanable</span><span class="variable">.dirty</span><span class="variable">.ratio</span> -&gt; <span class="number">0</span><span class="variable">.5</span>, index<span class="variable">.interval</span><span class="variable">.bytes</span> -&gt; <span class="number">4096</span>, unclean<span class="variable">.leader</span><span class="variable">.election</span><span class="variable">.enable</span> -&gt; false, retention<span class="variable">.bytes</span> -&gt; -<span class="number">1</span>, delete<span class="variable">.retention</span><span class="variable">.ms</span> -&gt; <span class="number">86400000</span>, segment<span class="variable">.ms</span> -&gt; <span class="number">604800000</span>, message<span class="variable">.timestamp</span><span class="variable">.difference</span><span class="variable">.max</span><span class="variable">.ms</span> -&gt; <span class="number">9223372036854775807</span>, segment<span class="variable">.index</span><span class="variable">.bytes</span> -&gt; <span class="number">10485760</span>&#125;. (kafka<span class="variable">.log</span><span class="variable">.LogManager</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">631</span>] INFO [Partition test-<span class="number">0</span> broker=<span class="number">0</span>] No checkpointed highwatermark is found <span class="keyword">for</span> partition test-<span class="number">0</span> (kafka<span class="variable">.cluster</span><span class="variable">.Partition</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">631</span>] INFO [Partition test-<span class="number">0</span> broker=<span class="number">0</span>] Log loaded <span class="keyword">for</span> partition test-<span class="number">0</span> <span class="keyword">with</span> <span class="keyword">initial</span> high watermark <span class="number">0</span> (kafka<span class="variable">.cluster</span><span class="variable">.Partition</span>)</span><br><span class="line">[<span class="number">2020</span>-<span class="number">02</span>-<span class="number">03</span> <span class="number">16</span>:<span class="number">12</span>:<span class="number">27</span>,<span class="number">632</span>] INFO [Partition test-<span class="number">0</span> broker=<span class="number">0</span>] test-<span class="number">0</span> starts at Leader Epoch <span class="number">0</span> from offset <span class="number">0</span>. Previous Leader Epoch was: -<span class="number">1</span> (kafka<span class="variable">.cluster</span><span class="variable">.Partition</span>)</span><br></pre></td></tr></table></figure><h5 id="生产者生产消息"><a href="#生产者生产消息" class="headerlink" title="生产者生产消息"></a>生产者生产消息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h5 id="消费者消费消息"><a href="#消费者消费消息" class="headerlink" title="消费者消费消息"></a>消费者消费消息</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br></pre></td></tr></table></figure><h5 id="查看所有的topic"><a href="#查看所有的topic" class="headerlink" title="查看所有的topic"></a>查看所有的topic</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics  --list --zookeeper localhost:2181</span><br><span class="line">__consumer_offsets</span><br><span class="line">_schemas</span><br><span class="line"><span class="built_in">test</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在mac上安装kafka很简单，直接brew install 即可。安装完之后启动，参照brew的提示&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;li
      
    
    </summary>
    
    
      <category term="Kafka" scheme="http://shiningstarpxx.github.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-跳表</title>
    <link href="http://shiningstarpxx.github.com/2019/08/23/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-%E8%B7%B3%E8%A1%A8/"/>
    <id>http://shiningstarpxx.github.com/2019/08/23/redis源码阅读-跳表/</id>
    <published>2019-08-23T01:25:39.000Z</published>
    <updated>2019-08-26T10:44:10.868Z</updated>
    
    <content type="html"><![CDATA[<p>先看一下原始的skiplist, <a href="https://epaperpress.com/sortsearch/download/skiplist.pdf" target="_blank" rel="noopener">Skip Lists: A Probabilistic Altervative to Balanced Trees</a> . 既然是一个list，那么普通的list有什么问题</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/sorted_linked_list.png?raw=true" alt></p><p>在链表中查找一个目标值，平均时间复杂度是O(n), 不管链表是否有序。通常这种判断目标值是否存在通常的解决办法是</p><ol><li>hash table</li><li>有序数组，二分查找</li><li><p>各种平衡树</p><p>那能否在list的数据结构下，也有类似平衡树的效率呢。上面的论文就按照这个思路，设计出了一套解决方案。</p></li></ol><p>试想如果链表里单数的节点互相连接，这样查找一个数据的平均次数可以减少一半。如下图所示，</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/skip2node_linked_list.png?raw=true" alt></p><p>假如寻找23，之间是一共遍历6个节点，现在是4个节点，减少一半是n/2 + 1,</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/search_path_on_skip2node_list.png?raw=true" alt></p><p>如果层数变成三层，一次跳过的节点会更多。</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/skip2node_level3_linked_list.png?raw=true" alt></p><p>整体的思想如上，论文里对于一些细节做了进一步优化，对于空间效率和查找效率之间做了一些平衡，在保障查找效率的情况下，空间上也进一步得到了压缩。感兴趣可以进一步深入研究论文，下面只给出一个skiplist构建的可能过程示意</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/skiplist_insertions.png?raw=true" alt></p><p>Redisli的zskiplist 里面数据存储的情况如下 </p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/redis_skiplist_example.png?raw=true" alt></p><ul><li>源码分析部分</li></ul><p>跳表的创建很有意思，list中的level默认是一，不会用第一个节点的level来更新list的level</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Create a new skiplist. */</span></span><br><span class="line"><span class="function">zskiplist *<span class="title">zslCreate</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> j;</span><br><span class="line">    zskiplist *zsl;</span><br><span class="line"></span><br><span class="line">    zsl = zmalloc(<span class="keyword">sizeof</span>(*zsl));</span><br><span class="line">    zsl-&gt;level = <span class="number">1</span>;</span><br><span class="line">    zsl-&gt;length = <span class="number">0</span>;</span><br><span class="line">    zsl-&gt;header = zslCreateNode(ZSKIPLIST_MAXLEVEL,<span class="number">0</span>,<span class="literal">NULL</span>);</span><br><span class="line">    <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; ZSKIPLIST_MAXLEVEL; j++) &#123;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].forward = <span class="literal">NULL</span>;</span><br><span class="line">        zsl-&gt;header-&gt;level[j].span = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    zsl-&gt;header-&gt;backward = <span class="literal">NULL</span>;</span><br><span class="line">    zsl-&gt;tail = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> zsl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;先看一下原始的skiplist, &lt;a href=&quot;https://epaperpress.com/sortsearch/download/skiplist.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Skip Lists: A Probabil
      
    
    </summary>
    
    
      <category term="redis" scheme="http://shiningstarpxx.github.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-sds字符串</title>
    <link href="http://shiningstarpxx.github.com/2019/08/22/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-sds%E5%AD%97%E7%AC%A6%E4%B8%B2/"/>
    <id>http://shiningstarpxx.github.com/2019/08/22/redis源码阅读-sds字符串/</id>
    <published>2019-08-22T10:07:47.000Z</published>
    <updated>2019-08-22T12:38:24.922Z</updated>
    
    <content type="html"><![CDATA[<p>redis里的字符串数据结构是sds（simple dynamic string）,这个是redis里面字符串使用的默认数据结构。而c的字符串只是作为常量使用。</p><p>redis自建的SDS字符串除了保存数据库中的字符串外，还用于缓冲区. SDS的数据结构如下,  以8的举例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> __<span class="title">attribute__</span> ((__<span class="title">packed__</span>)) <span class="title">sdshdr8</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint8_t</span> len; <span class="comment">/* used */</span></span><br><span class="line">    <span class="keyword">uint8_t</span> alloc; <span class="comment">/* excluding the header and null terminator */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> flags; <span class="comment">/* 3 lsb of type, 5 unused bits */</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>需要注意的是，之前的数据结构是 len, free; 而新版的改成了 len， alloc；自然 free = alloc - len</p><p>SDS与C字符串的区别</p><ol><li>常数级时间获取字符串的长度</li><li>杜绝缓存区溢出，自己实现了字符串的拷贝，相加等等</li><li>减少字符串变更时内存的重新分配次数<ol><li>空间预分配，经典的2^n 步长来预留足够空间</li><li>惰性的空间释放，在字符串变短后，也不立即释放空间</li></ol></li><li>二进制安全，因redis里面可以存储二进制数据，比如protobuf 编码后的二进制数据</li><li>兼容部分C字符串函数，字符串数据以\0结尾，可以直接和C的字符串想操作</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;redis里的字符串数据结构是sds（simple dynamic string）,这个是redis里面字符串使用的默认数据结构。而c的字符串只是作为常量使用。&lt;/p&gt;
&lt;p&gt;redis自建的SDS字符串除了保存数据库中的字符串外，还用于缓冲区. SDS的数据结构如下,  
      
    
    </summary>
    
    
      <category term="redis" scheme="http://shiningstarpxx.github.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-dict</title>
    <link href="http://shiningstarpxx.github.com/2019/08/22/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-dict/"/>
    <id>http://shiningstarpxx.github.com/2019/08/22/redis源码阅读-dict/</id>
    <published>2019-08-22T01:07:08.000Z</published>
    <updated>2019-08-22T01:13:25.548Z</updated>
    
    <content type="html"><![CDATA[<h4 id="Redis字典具有以下特点："><a href="#Redis字典具有以下特点：" class="headerlink" title="Redis字典具有以下特点："></a>Redis字典具有以下特点：</h4><ul><li>Redis字典的底层实现为哈希表，</li><li>每个字典使用两个哈希表， 一般情况下只使用 0 号哈希表， 只有在 rehash 进行时， 才会同时使用 0 号和 1 号哈希表。</li><li>哈希表使用链地址法来解决键冲突的问题。</li><li>自动 Rehash 扩展或收缩哈希表。</li><li>对哈希表的 rehash 是分多次、渐进式地进行的。</li></ul><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * hash节点</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//值</span></span><br><span class="line">    <span class="keyword">union</span> &#123;</span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        <span class="keyword">uint64_t</span> u64;</span><br><span class="line">        <span class="keyword">int64_t</span> s64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指向下一个节点</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//桶</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针数组大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指针数组掩码，用于计算索引值</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//hash表现有节点数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型处理函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类型处理函数私有值</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//两个hash表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//rehash标示，为－1表示不在rehash，不为0表示正在rehash的桶</span></span><br><span class="line">    <span class="keyword">int</span> rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//当前正在运行的安全迭代器数量</span></span><br><span class="line">    <span class="keyword">int</span> iterators; <span class="comment">/* number of iterators currently running */</span></span><br><span class="line">&#125; dict;</span><br></pre></td></tr></table></figure><h4 id="dic的数据结构"><a href="#dic的数据结构" class="headerlink" title="dic的数据结构"></a>dic的数据结构</h4><p><img src="https://raw.githubusercontent.com/shiningstarpxx/blog_pic/master/dic1.png" alt></p><h4 id="字典中添加元素的过程"><a href="#字典中添加元素的过程" class="headerlink" title="字典中添加元素的过程"></a>字典中添加元素的过程</h4><p><img src="https://raw.githubusercontent.com/shiningstarpxx/blog_pic/master/dic2.png" alt></p><h2 id="rehash介绍"><a href="#rehash介绍" class="headerlink" title="rehash介绍"></a>rehash介绍</h2><p>字典的 rehash 操作实际上就是执行以下任务：</p><p>创建一个比 ht[0]-&gt;table 更大的 ht[1]-&gt;table ， size为大于used*2的2的指数, 开始值为4；</p><p>将 ht[0]-&gt;table 中的所有键值对迁移到 ht[1]-&gt;table ；</p><p>将原有 ht[0] 的数据清空，并将 ht[1] 替换为新的 ht[0] ；</p><p>进行rehash的条件：</p><p>自然 rehash ： ratio &gt;= 1 ，且变量 dict_can_resize 为真。</p><p>强制 rehash ： ratio 大于变量 dict_force_resize_ratio （目前版本中， dict_force_resize_ratio 的值为 5 ）。</p><p>阶进rehash：</p><p>主动方式：databaseCron中调用dictRehashMilliseconds执行一毫秒。</p><p>被动方式：调用dictAdd，dicFind，dictDelete，dictGetRandomKey时，调用_dictRehashStep，迁移一个非空桶。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;Redis字典具有以下特点：&quot;&gt;&lt;a href=&quot;#Redis字典具有以下特点：&quot; class=&quot;headerlink&quot; title=&quot;Redis字典具有以下特点：&quot;&gt;&lt;/a&gt;Redis字典具有以下特点：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;Redis字典的底层实现为哈希表
      
    
    </summary>
    
    
      <category term="redis" scheme="http://shiningstarpxx.github.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>redis源码阅读-adlist</title>
    <link href="http://shiningstarpxx.github.com/2019/08/22/redis%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB-adlist/"/>
    <id>http://shiningstarpxx.github.com/2019/08/22/redis源码阅读-adlist/</id>
    <published>2019-08-22T01:04:41.000Z</published>
    <updated>2019-08-22T01:05:34.730Z</updated>
    
    <content type="html"><![CDATA[<h2 id="background"><a href="#background" class="headerlink" title="background"></a>background</h2><p>这里其实想谈谈为什么要做redis的source code reading &amp; analysing。动机有点尴尬，因为在大厂的工作中，开源的工具使用较少，时间长了竟然会成为一个被外部人员低看一眼的理由。当然，对于面试应该考察什么这个话题，我也一肚子槽想吐，找个机会会一并写出。</p><p>话不多说，言归正传</p><h2 id="adlist是什么"><a href="#adlist是什么" class="headerlink" title="adlist是什么"></a>adlist是什么</h2><p>adlist - A generic doubly linked list implementation，就是一个通用的双向列表实现。</p><h2 id="adlist的数据结构"><a href="#adlist的数据结构" class="headerlink" title="adlist的数据结构"></a>adlist的数据结构</h2><p>一个典型的list，一定会有node，这个实现比较完备，同时提供了iterator。于是这里至少有三个数据结构</p><h3 id="listNode"><a href="#listNode" class="headerlink" title="listNode"></a>listNode</h3><p>Node是链表中的每个节点的定义与抽象，其中value可以是更丰富的类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listNode &#123;</span><br><span class="line">struct listNode *prev;</span><br><span class="line">struct listNode *next;</span><br><span class="line">void *value;</span><br><span class="line">&#125; listNode;</span><br></pre></td></tr></table></figure><h3 id="listIter"><a href="#listIter" class="headerlink" title="listIter"></a>listIter</h3><p>迭代器用于遍历整个list</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">typedef struct listIter &#123;</span><br><span class="line">    listNode *next;</span><br><span class="line">    int direction;</span><br><span class="line">&#125; listIter;</span><br></pre></td></tr></table></figure><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>list是真正对外操作的数据结构，有几个重要的参数，head，tail用于分别表示头节点和尾节点，len是用于记录当前的链表长度，这样length操作就是O（1）的时间复杂度。另外，为了使链表更有通用性，即基于value的复杂性，提供了dup，free，match三个特殊的函数指针用于专门操作value部分</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">typedef struct list &#123;</span><br><span class="line">    listNode *head;</span><br><span class="line">    listNode *tail;</span><br><span class="line">    void *(*dup)(void *ptr);</span><br><span class="line">    void (*free)(void *ptr);</span><br><span class="line">    int (*match)(void *ptr, void *key);</span><br><span class="line">    unsigned long len;</span><br><span class="line">&#125; list;</span><br></pre></td></tr></table></figure><h3 id="list操作部分，宏部分"><a href="#list操作部分，宏部分" class="headerlink" title="list操作部分，宏部分"></a>list操作部分，宏部分</h3><p>这部分操作是可以根据list的成员变量直接获得的，定义函数的好处是，接口更统一易读</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/* Functions implemented as macros */</span><br><span class="line">#define listLength(l) ((l)-&gt;len)</span><br><span class="line">#define listFirst(l) ((l)-&gt;head)</span><br><span class="line">#define listLast(l) ((l)-&gt;tail)</span><br><span class="line">#define listPrevNode(n) ((n)-&gt;prev)</span><br><span class="line">#define listNextNode(n) ((n)-&gt;next)</span><br><span class="line">#define listNodeValue(n) ((n)-&gt;value)</span><br><span class="line"></span><br><span class="line">#define listSetDupMethod(l,m) ((l)-&gt;dup = (m))</span><br><span class="line">#define listSetFreeMethod(l,m) ((l)-&gt;free = (m))</span><br><span class="line">#define listSetMatchMethod(l,m) ((l)-&gt;match = (m))</span><br><span class="line"></span><br><span class="line">#define listGetDupMethod(l) ((l)-&gt;dup)</span><br><span class="line">#define listGetFree(l) ((l)-&gt;free)</span><br><span class="line">#define listGetMatchMethod(l) ((l)-&gt;match)</span><br></pre></td></tr></table></figure><h3 id="iterator的操作方向，也是宏定义"><a href="#iterator的操作方向，也是宏定义" class="headerlink" title="iterator的操作方向，也是宏定义"></a>iterator的操作方向，也是宏定义</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/* Directions for iterators */</span><br><span class="line">#define AL_START_HEAD 0</span><br><span class="line">#define AL_START_TAIL 1</span><br></pre></td></tr></table></figure><h3 id="函数操作的部分，需要代码实现部分的对于接口定义"><a href="#函数操作的部分，需要代码实现部分的对于接口定义" class="headerlink" title="函数操作的部分，需要代码实现部分的对于接口定义"></a>函数操作的部分，需要代码实现部分的对于接口定义</h3><p>接口的定义基本上都非常的通俗易懂，大部分其意自明。这里重点描述一下几个函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">listRewind,  表示把迭代器指向头部，并且从头部开始遍历</span><br><span class="line">listRewindTail，把迭代器指向尾部，遍历方向设置为从尾部开始</span><br><span class="line">listRotate，表示把最后一个元素挪到第一个去</span><br><span class="line">listSearchKey，表示在链表中找到value = key 的节点</span><br><span class="line">listIndex，表示链表从头或者从尾部，找到第index个节点</span><br><span class="line"></span><br><span class="line">/* Prototypes */</span><br><span class="line">list *listCreate(void);</span><br><span class="line">void listRelease(list *list);</span><br><span class="line">list *listAddNodeHead(list *list, void *value);</span><br><span class="line">list *listAddNodeTail(list *list, void *value);</span><br><span class="line">list *listInsertNode(list *list, listNode *old_node, void *value, int after);</span><br><span class="line">void listDelNode(list *list, listNode *node);</span><br><span class="line">listIter *listGetIterator(list *list, int direction);</span><br><span class="line">listNode *listNext(listIter *iter);</span><br><span class="line">void listReleaseIterator(listIter *iter);</span><br><span class="line">list *listDup(list *orig);</span><br><span class="line">listNode *listSearchKey(list *list, void *key);</span><br><span class="line">listNode *listIndex(list *list, long index);</span><br><span class="line">void listRewind(list *list, listIter *li);</span><br><span class="line">void listRewindTail(list *list, listIter *li);</span><br><span class="line">void listRotate(list *list);</span><br></pre></td></tr></table></figure><h4 id="函数操作的实现部分"><a href="#函数操作的实现部分" class="headerlink" title="函数操作的实现部分"></a>函数操作的实现部分</h4><p>这部分都在adlist.c中，代码实现很优美，建议日常的链表操作都可以参考这里代码实现。举一个实现比较优雅的例子</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">listNode *listNext(listIter *iter)</span><br><span class="line">&#123;</span><br><span class="line">    listNode *current = iter-&gt;next;</span><br><span class="line"></span><br><span class="line">    if (current != NULL) &#123;</span><br><span class="line">        if (iter-&gt;direction == AL_START_HEAD)</span><br><span class="line">            iter-&gt;next = current-&gt;next;</span><br><span class="line">        else</span><br><span class="line">            iter-&gt;next = current-&gt;prev;</span><br><span class="line">    &#125;</span><br><span class="line">    return current;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>除了实现列表类型以外， 双端链表还被很多 Redis 内部模块所应用：</p><ul><li>事务模块使用双端链表依序保存输入的命令；</li><li>服务器模块使用双端链表来保存多个客户端；</li><li>订阅/发送模块使用双端链表来保存订阅模式的多个客户端；</li><li>事件模块使用双端链表来保存时间事件（time event）；</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;background&quot;&gt;&lt;a href=&quot;#background&quot; class=&quot;headerlink&quot; title=&quot;background&quot;&gt;&lt;/a&gt;background&lt;/h2&gt;&lt;p&gt;这里其实想谈谈为什么要做redis的source code reading 
      
    
    </summary>
    
    
      <category term="redis" scheme="http://shiningstarpxx.github.com/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>flink step 1</title>
    <link href="http://shiningstarpxx.github.com/2019/05/23/flink-step-1/"/>
    <id>http://shiningstarpxx.github.com/2019/05/23/flink-step-1/</id>
    <published>2019-05-23T08:33:58.000Z</published>
    <updated>2019-05-23T09:30:50.288Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>流式处理在大数据系统中是必备的。当下比较火的是flink，sparkstreaming。目前我们的系统中使用的flink，趁这两天不忙计划打开官方文档快速看看。</p><h2 id="flink下载和启动"><a href="#flink下载和启动" class="headerlink" title="flink下载和启动"></a>flink下载和启动</h2><p>flink天然支持mac os，所以以下操作不需要在linux上完成。</p><p>首先，查看java的版本</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ java --version</span><br><span class="line">java 10.0.2 2018-07-17</span><br><span class="line">Java(TM) SE Runtime Environment 18.3 (build 10.0.2+13)</span><br><span class="line">Java HotSpot(TM) 64-Bit Server VM 18.3 (build 10.0.2+13, mixed mode)</span><br></pre></td></tr></table></figure><p>然后，安装flink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ brew install apache-flink</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">$ flink --version</span><br><span class="line">Version: 1.8.0, Commit ID: 4caec0d</span><br></pre></td></tr></table></figure><p>查看flink的安装目录 &amp; 进入到改目录</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ brew info apache-flink</span><br><span class="line">apache-flink: stable 1.8.0, HEAD</span><br><span class="line">Scalable batch and stream data processing</span><br><span class="line">https://flink.apache.org/</span><br><span class="line">/usr/<span class="built_in">local</span>/Cellar/apache-flink/1.8.0 (155 files, 320.2MB) *</span><br><span class="line"></span><br><span class="line">$ <span class="built_in">cd</span> /usr/<span class="built_in">local</span>/Cellar/apache-flink/1.8.0/libexec</span><br></pre></td></tr></table></figure><p>开始启动flink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/start-cluster.sh  <span class="comment"># Start Flink</span></span><br></pre></td></tr></table></figure><p>这个时候可以看到有个界面, 通过地址查看<a href="[http://localhost:8081](http://localhost:8081/">flink状态</a> )</p><p><img src="https://github.com/shiningstarpxx/blog_pic/blob/master/flink-pic.png?raw=true" alt></p><p>查看flink的log 信息</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$  tail <span class="built_in">log</span>/flink-*-standalonesession-*.<span class="built_in">log</span></span><br><span class="line">2019-05-23 17:18:47,543 INFO  org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint    - Rest endpoint listening at localhost:8081</span><br><span class="line">2019-05-23 17:18:47,544 INFO  org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint    - http://localhost:8081 was granted leadership with leaderSessionID=00000000-0000-0000-0000-000000000000</span><br><span class="line">2019-05-23 17:18:47,544 INFO  org.apache.flink.runtime.dispatcher.DispatcherRestEndpoint    - Web frontend listening at http://localhost:8081.</span><br><span class="line">2019-05-23 17:18:47,670 INFO  org.apache.flink.runtime.rpc.akka.AkkaRpcService              - Starting RPC endpoint <span class="keyword">for</span> org.apache.flink.runtime.resourcemanager.StandaloneResourceManager at akka://flink/user/resourcemanager .</span><br><span class="line">2019-05-23 17:18:47,700 INFO  org.apache.flink.runtime.rpc.akka.AkkaRpcService              - Starting RPC endpoint <span class="keyword">for</span> org.apache.flink.runtime.dispatcher.StandaloneDispatcher at akka://flink/user/dispatcher .</span><br><span class="line">2019-05-23 17:18:47,729 INFO  org.apache.flink.runtime.resourcemanager.StandaloneResourceManager  - ResourceManager akka.tcp://flink@localhost:6123/user/resourcemanager was granted leadership with fencing token 00000000000000000000000000000000</span><br><span class="line">2019-05-23 17:18:47,730 INFO  org.apache.flink.runtime.resourcemanager.slotmanager.SlotManager  - Starting the SlotManager.</span><br><span class="line">2019-05-23 17:18:47,742 INFO  org.apache.flink.runtime.dispatcher.StandaloneDispatcher      - Dispatcher akka.tcp://flink@localhost:6123/user/dispatcher was granted leadership with fencing token 00000000-0000-0000-0000-000000000000</span><br><span class="line">2019-05-23 17:18:47,744 INFO  org.apache.flink.runtime.dispatcher.StandaloneDispatcher      - Recovering all persisted <span class="built_in">jobs</span>.</span><br><span class="line">2019-05-23 17:18:48,223 INFO  org.apache.flink.runtime.resourcemanager.StandaloneResourceManager  - Registering TaskManager with ResourceID c76f659d73a0d9c679d3effc68f5b50e (akka.tcp://flink@10.43.19.57:50055/user/taskmanager_0) at ResourceManager</span><br></pre></td></tr></table></figure><h2 id="执行一个例子"><a href="#执行一个例子" class="headerlink" title="执行一个例子"></a>执行一个例子</h2><p>完整的代码在github<a href="https://github.com/apache/flink/blob/master/flink-examples/flink-examples-streaming/src/main/java/org/apache/flink/streaming/examples/socket/SocketWindowWordCount.java" target="_blank" rel="noopener">java</a>上，下面是主要的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SocketWindowWordCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// the port to connect to</span></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> port;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">final</span> ParameterTool params = ParameterTool.fromArgs(args);</span><br><span class="line">            port = params.getInt(<span class="string">"port"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            System.err.println(<span class="string">"No port specified. Please run 'SocketWindowWordCount --port &lt;port&gt;'"</span>);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get the execution environment</span></span><br><span class="line">        <span class="keyword">final</span> StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// get input data by connecting to the socket</span></span><br><span class="line">        DataStream&lt;String&gt; text = env.socketTextStream(<span class="string">"localhost"</span>, port, <span class="string">"\n"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// parse the data, group it, window it, and aggregate the counts</span></span><br><span class="line">        DataStream&lt;WordWithCount&gt; windowCounts = text</span><br><span class="line">            .flatMap(<span class="keyword">new</span> FlatMapFunction&lt;String, WordWithCount&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flatMap</span><span class="params">(String value, Collector&lt;WordWithCount&gt; out)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (String word : value.split(<span class="string">"\\s"</span>)) &#123;</span><br><span class="line">                        out.collect(<span class="keyword">new</span> WordWithCount(word, <span class="number">1L</span>));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;)</span><br><span class="line">            .keyBy(<span class="string">"word"</span>)</span><br><span class="line">            .timeWindow(Time.seconds(<span class="number">5</span>), Time.seconds(<span class="number">1</span>))</span><br><span class="line">            .reduce(<span class="keyword">new</span> ReduceFunction&lt;WordWithCount&gt;() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> WordWithCount <span class="title">reduce</span><span class="params">(WordWithCount a, WordWithCount b)</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">new</span> WordWithCount(a.word, a.count + b.count);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// print the results with a single thread, rather than in parallel</span></span><br><span class="line">        windowCounts.print().setParallelism(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        env.execute(<span class="string">"Socket Window WordCount"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Data type for words with count</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">WordWithCount</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">public</span> String word;</span><br><span class="line">        <span class="keyword">public</span> <span class="keyword">long</span> count;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordWithCount</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">WordWithCount</span><span class="params">(String word, <span class="keyword">long</span> count)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.word = word;</span><br><span class="line">            <span class="keyword">this</span>.count = count;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> word + <span class="string">" : "</span> + count;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="执行样例"><a href="#执行样例" class="headerlink" title="执行样例"></a>执行样例</h3><p>在安装好的代码里就有对应的jar包，不需要自己编译生成</p><p>先打开一个proxy，</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 9000</span><br></pre></td></tr></table></figure><p>提交flink的job</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/flink run examples/streaming/SocketWindowWordCount.jar --port 9000</span><br><span class="line">Starting execution of program</span><br></pre></td></tr></table></figure><p>在nc窗口里做一些输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ nc -l 9000</span><br><span class="line">lorem ipsum</span><br><span class="line">ipsum ipsum ipsum</span><br><span class="line"><span class="built_in">bye</span></span><br></pre></td></tr></table></figure><p>查看日志，得到输出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f <span class="built_in">log</span>/flink-*-taskexecutor-*.out</span><br><span class="line"><span class="built_in">bye</span> : 1</span><br><span class="line">ipsum : 4</span><br><span class="line">lorem : 1</span><br></pre></td></tr></table></figure><p>结束flink</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/stop-cluster.sh</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;流式处理在大数据系统中是必备的。当下比较火的是flink，sparkstreaming。目前我们的系统中使用的flink，趁这两天不忙计划打
      
    
    </summary>
    
    
      <category term="flink" scheme="http://shiningstarpxx.github.com/tags/flink/"/>
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
  </entry>
  
  <entry>
    <title>hexo增加评论</title>
    <link href="http://shiningstarpxx.github.com/2019/04/24/hexo%E5%A2%9E%E5%8A%A0%E8%AF%84%E8%AE%BA/"/>
    <id>http://shiningstarpxx.github.com/2019/04/24/hexo增加评论/</id>
    <published>2019-04-24T13:49:47.000Z</published>
    <updated>2019-04-24T13:50:50.795Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://yashuning.github.io/2018/06/29/hexo-Next-主题添加评论功能/" target="_blank" rel="noopener">本文系转载</a></p><p>Hexo 的 Next 主题继承了多种评论系统，我在这里介绍两种个人觉得不错的评论系统：Valine 和 gitment</p><h3 id="Valine-评论系统"><a href="#Valine-评论系统" class="headerlink" title="Valine 评论系统"></a>Valine 评论系统</h3><p>使用 Valine 评论系统，这款系统不需要登录便可以登录，没有后端，Next 主题最新已经支持安装</p><ul><li>基于 Leancloud 的系统</li><li>支持 MarkDown 语法</li><li>无后端实现，快速高效</li></ul><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><h5 id="注册-LeanCloud"><a href="#注册-LeanCloud" class="headerlink" title="注册 LeanCloud"></a>注册 LeanCloud</h5><p>因为 Valine 是基于 LeanCloud 系统的，所以先在 LeanCloud 中注册账号</p><p><a href="https://leancloud.cn/dashboard/login.html#/signin" target="_blank" rel="noopener">LeanCloud官网登录入口</a></p><p>注册登陆后，访问控制台，创建应用，选择开发版，创建好之后就生成了 <code>App ID</code> 和 <code>App Key</code></p><h5 id="设置-Next-主题"><a href="#设置-Next-主题" class="headerlink" title="设置 Next 主题"></a>设置 Next 主题</h5><p>在主题的配置文件中，修改关于 valine 的配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># Valine.</span><br><span class="line"># You can get your appid and appkey from https://leancloud.cn</span><br><span class="line"># more info please open https://valine.js.org</span><br><span class="line">valine:</span><br><span class="line">  enable: true # 是否开启</span><br><span class="line">  appid:   # 上一步获取的 App ID</span><br><span class="line">  appkey:  # 上一步获取的 App Key</span><br><span class="line">  notify: false # 新留言是否需要通知 https://github.com/xCss/Valine/wiki</span><br><span class="line">  verify: false # 是否需要验证，验证比较反人类建议false关闭</span><br><span class="line">  placeholder: 请在此输入您的留言 # 默认留言框内的文字</span><br><span class="line">  avatar: mm # 默认头像</span><br><span class="line">  guest_info: nick,mail # 默认留言框的头部需要访问者输入的信息</span><br><span class="line">  pageSize: 10 # pagination size #默认单页的留言条数</span><br></pre></td></tr></table></figure><p>重新部署</p><h4 id="评论管理"><a href="#评论管理" class="headerlink" title="评论管理"></a>评论管理</h4><p>如果想要管理评论，进入 leancloud 官网，找到 <code>控制台</code>-&gt;<code>存储</code>-&gt;<code>commet</code> 中进行管理</p><h3 id="Gitment-评论系统"><a href="#Gitment-评论系统" class="headerlink" title="Gitment 评论系统"></a>Gitment 评论系统</h3><p>gitment，它是基于 github 开发的，是依靠于 <code>GitHub Issues</code> 的评论系统，Next 主题最新已经支持安装</p><p>前提：更新 Next 主题（5.1.2 主题）</p><h4 id="注册OAuth-application"><a href="#注册OAuth-application" class="headerlink" title="注册OAuth application"></a>注册OAuth application</h4><ol><li><p>在 github 中进行注册，进入 <a href="https://github.com/settings/profile" target="_blank" rel="noopener">https://github.com/settings/profile</a></p></li><li><p>点击左侧 Developer settings</p></li><li><p>Register a new application</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Application name:#应用名称</span><br><span class="line">Homepage URL：  #网站URL(填自己的博客主页地址)</span><br><span class="line">Application description#描述</span><br><span class="line">Authorization callback URL:#网站URL(填自己的博客主页地址)</span><br></pre></td></tr></table></figure></li><li><p>注册完成之后，会得到：<code>Client ID</code> 和 <code>Client Secret</code></p></li></ol><h4 id="新建存放博客评论仓库"><a href="#新建存放博客评论仓库" class="headerlink" title="新建存放博客评论仓库"></a>新建存放博客评论仓库</h4><p>可以在 github 中建一个项目，专门用来存储你的博客评论</p><h4 id="配置-next-主题文件"><a href="#配置-next-主题文件" class="headerlink" title="配置 next 主题文件"></a>配置 next 主题文件</h4><p>编辑主题配置文件：themes\next\ _config.yml，找到有关 gitment 的设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">gitment:   </span><br><span class="line">  enable:  true</span><br><span class="line">  mint: true  </span><br><span class="line">  count: true </span><br><span class="line">  lazy: false  #评论懒加载，如果true，则默认不展示评论，点击按钮查看评论</span><br><span class="line">  cleanly: false  </span><br><span class="line">  language: </span><br><span class="line">  github_user: #github名称</span><br><span class="line">  github_repo: BlogComments#上一步新建存放评论的仓库名</span><br><span class="line">  client_id: b8bad0exxxx#上面注册 OAuth Application 的 Client ID</span><br><span class="line">  client_secret: bcee560xxxxxx#上面注册 OAuth Application 申请的 Client Secret</span><br><span class="line">  proxy_gateway: </span><br><span class="line">  redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint</span><br></pre></td></tr></table></figure><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>在设置完成之后，hexo 重新部署</p><p>每篇文章都要点击初始化评论按钮</p><h4 id="评论"><a href="#评论" class="headerlink" title="评论"></a>评论</h4><p>评论显示在新建存放评论的仓库中的 <code>issue</code> 中</p><h3 id="关闭某个页面的评论"><a href="#关闭某个页面的评论" class="headerlink" title="关闭某个页面的评论"></a>关闭某个页面的评论</h3><p>在页面的 <code>Front-matter</code> 中添加 <code>comments</code> 字段，设为 <code>false</code></p><p>比如标签页不想要评论，则在标签页面中做以下设置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">title: 标签</span><br><span class="line">date: 2015-12-16 17:05:24</span><br><span class="line">type: &quot;tags&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://yashuning.github.io/2018/06/29/hexo-Next-主题添加评论功能/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;本文系转载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;Hexo 的 Next 主题继承了多种评
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>java项目使用bazel</title>
    <link href="http://shiningstarpxx.github.com/2019/04/24/java%E9%A1%B9%E7%9B%AE%E4%BD%BF%E7%94%A8bazel/"/>
    <id>http://shiningstarpxx.github.com/2019/04/24/java项目使用bazel/</id>
    <published>2019-04-24T08:58:23.000Z</published>
    <updated>2019-04-24T13:33:22.730Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>现代项目中，大多很难做到单一语言开发。以在线服务举例，比如传统的管理系统大多是php，python来写的，数据进入db，大多是mysql；而对线上提供服务的可能是c/c++, java, 也可能是go，也可能是erlang，当然也可以用php，python，nodejs；数据处理部分则大多是java，scala或者python；报表数据处理则通常是sql。这么多项目的代码如何组织，成为了一个专门的课题，几乎每个大型项目都有一个规模或大或小的团队来专门维护代码仓库；其中最难管理的部分是，如何统一各个不同语言的构建，以期望能做到ci &amp; cd。</p><p>当然，粗暴的方法是每个子项目自己出人，自己构建，自己维护特定的ci &amp; cd。这种方案最大的特点是，直接；但是造成的资源浪费，以及先进的生产力无法复用，也将是必然的事情。</p><p>所以，顶级的公司的解决方案，是提供整个项目统一构建的能力，比如google的Bazel，facebook的buck，腾讯的blade都算是业界中相对比较好用的。</p><h3 id="Bazel使用"><a href="#Bazel使用" class="headerlink" title="Bazel使用"></a>Bazel使用</h3><p>bazel，buck，blade都有人使用；在之前的项目中是全部使用了blade，其实blade也非常好用了。不过bazel因为支持了tensorflow，再者bazel的跨平台性要更好；另外，我猜测g家的开源质量相对比较高，后续的维护升级应该不成问题。故在新的项目中尝试引入了bazel。</p><p>目前新的项目，大量子项目是用golang写的，另外一部分是java项目，之前用maven编译。现在面临的问题是，如果顺利的把项目从maven迁移到bazel。</p><p>尝试迁移的过程中，遇到了很多问题，这里一一记录下来，后续可以回顾和借鉴。</p><h4 id="配置WORKSPACE"><a href="#配置WORKSPACE" class="headerlink" title="配置WORKSPACE"></a>配置WORKSPACE</h4><p>为了支持maven，要把对应的maven里的配置改成WORKSPACE中的maven_jar, 这里举例说明</p><p>Maven 的配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.yaml<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>snakeyaml<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.11<span class="tag">&lt;/<span class="name">version</span>&gt;</span> <span class="comment">&lt;!-- Or whatever JUnit you're using. --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>对应的WORKSPACE如下, 目前url尝试换成了国内ali云的并不成功，这里需要TODO去研究一下为什么。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">25</span> maven_jar(</span><br><span class="line"><span class="number">26</span>         name = <span class="string">"org_yaml"</span>,</span><br><span class="line"><span class="number">27</span>         artifact = <span class="string">"org.yaml:snakeyaml:1.21"</span>,</span><br><span class="line"><span class="number">28</span>     server = <span class="string">"maven_uk_server"</span>,</span><br><span class="line"><span class="number">29</span> )</span><br><span class="line"><span class="number">30</span></span><br><span class="line"><span class="number">31</span> maven_jar(</span><br><span class="line"><span class="number">32</span>         name = <span class="string">"junit"</span>,</span><br><span class="line"><span class="number">33</span>         artifact = <span class="string">"junit:junit:4.11"</span>,</span><br><span class="line"><span class="number">34</span>     server = <span class="string">"maven_uk_server"</span>,</span><br><span class="line"><span class="number">35</span> )</span><br><span class="line"><span class="number">36</span></span><br><span class="line"><span class="number">37</span> maven_server(</span><br><span class="line"><span class="number">38</span>     name = <span class="string">"maven_uk_server"</span>,</span><br><span class="line"><span class="number">39</span>     url = <span class="string">"http://uk.maven.org/maven2"</span>,</span><br><span class="line"><span class="number">43</span> )</span><br></pre></td></tr></table></figure><h4 id="编写BUILD文件"><a href="#编写BUILD文件" class="headerlink" title="编写BUILD文件"></a>编写BUILD文件</h4><p>经过半天调试，支持了原生java，用maven的包，以及相应的test。build文件如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"> <span class="number">1</span> java_library(</span><br><span class="line"> <span class="number">2</span>     name = <span class="string">"common"</span>,</span><br><span class="line"> <span class="number">3</span>     srcs = glob([<span class="string">"src/main/java/**/*.java"</span>]),</span><br><span class="line"> <span class="number">4</span>     resources = glob([<span class="string">"src/main/resources/*"</span>]),</span><br><span class="line"> <span class="number">6</span>     deps = [</span><br><span class="line"> <span class="number">7</span>     <span class="string">"@org_yaml//jar"</span>,</span><br><span class="line"> <span class="number">8</span>     ],</span><br><span class="line"> <span class="number">9</span> )</span><br><span class="line"><span class="number">10</span></span><br><span class="line"><span class="number">11</span> java_test(</span><br><span class="line"><span class="number">12</span>         name = <span class="string">"targeting_id_parser_test"</span>,</span><br><span class="line"><span class="number">13</span>         srcs = [<span class="string">"src/test/java/com/adshonor/datacube/TargetingIdParserTest.java"</span>],</span><br><span class="line"><span class="number">14</span>         test_class = <span class="string">"com.adshonor.datacube.TargetingIdParserTest"</span>,</span><br><span class="line"><span class="number">15</span>         data = glob([<span class="string">"src/main/resources/*"</span>]),</span><br><span class="line"><span class="number">16</span>         deps = [</span><br><span class="line"><span class="number">17</span>             <span class="string">"common"</span>,</span><br><span class="line"><span class="number">18</span>             <span class="string">"@junit//jar"</span>,</span><br><span class="line"><span class="number">19</span>         ],</span><br><span class="line"><span class="number">20</span> )</span><br></pre></td></tr></table></figure><p>需要注意的几点</p><ul><li>maven包依赖的写法 “@**//jar”</li><li>test中一定要指明test_class</li><li>test中如果用了解析配置文件，语法是data = ***</li><li>test中解析配置文件的路径一定是从WORKSPACE所在的路径写起，因为bazel应该是在WORKSPACE所在的root下面执行的。</li></ul><p>参照上面的例子去写，对应的java一定可以编译过。有疑问欢迎随时交流。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;现代项目中，大多很难做到单一语言开发。以在线服务举例，比如传统的管理系统大多是php，python来写的，数据进入db，大多是mysql；而
      
    
    </summary>
    
      <category term="统一构建" scheme="http://shiningstarpxx.github.com/categories/%E7%BB%9F%E4%B8%80%E6%9E%84%E5%BB%BA/"/>
    
    
      <category term="bazel" scheme="http://shiningstarpxx.github.com/tags/bazel/"/>
    
      <category term="java" scheme="http://shiningstarpxx.github.com/tags/java/"/>
    
      <category term="maven" scheme="http://shiningstarpxx.github.com/tags/maven/"/>
    
  </entry>
  
  <entry>
    <title>kafka-介绍-4</title>
    <link href="http://shiningstarpxx.github.com/2019/04/12/kafka-%E4%BB%8B%E7%BB%8D-4/"/>
    <id>http://shiningstarpxx.github.com/2019/04/12/kafka-介绍-4/</id>
    <published>2019-04-12T09:31:42.000Z</published>
    <updated>2019-04-12T13:51:47.447Z</updated>
    
    <content type="html"><![CDATA[<h5 id="效率"><a href="#效率" class="headerlink" title="效率"></a><a href="http://kafka.apache.org/documentation/#maximizingefficiency" target="_blank" rel="noopener">效率</a></h5><p>We have put significant effort into efficiency. One of our primary use cases is handling web activity data, which is very high volume: each page view may generate dozens of writes. Furthermore, we assume each message published is read by at least one consumer (often many), hence we strive to make consumption as cheap as possible. 主要使用是网页的活动数据，每个页面会产生几十条数据。而且，我们假设每个消息至少被至少一个消费者读取，因此我们需要尽可能降低消费成本</p><p>We have also found, from experience building and running a number of similar systems, that efficiency is a key to effective multi-tenant operations. If the downstream infrastructure service can easily become a bottleneck due to a small bump in usage by the application, such small changes will often create problems. By being very fast we help ensure that the application will tip-over under load before the infrastructure. This is particularly important when trying to run a centralized service that supports dozens or hundreds of applications on a centralized cluster as changes in usage patterns are a near-daily occurrence. 我们同样发现，效率对多租户的至关重要。因为很容易堵塞。</p><p>We discussed disk efficiency in the previous section. Once poor disk access patterns have been eliminated, there are two common causes of inefficiency in this type of system: too many small I/O operations, and excessive byte copying. 两种方式会造成效率不足：太多小的io操作和巨量的数据拷贝</p><p>The small I/O problem happens both between the client and the server and in the server’s own persistent operations.小的ip问题通常在client和server，或者server内部自己的一致性操作。</p><p>To avoid this, our protocol is built around a “message set” abstraction that naturally groups messages together. This allows network requests to group messages together and amortize the overhead of the network roundtrip rather than sending a single message at a time. The server in turn appends chunks of messages to its log in one go, and the consumer fetches large linear chunks at a time. 为了避免这个，我们的协议围绕着”message set”抽象来建立。这容许请求把消息group，避免每次发出一个消息的开销。server部分，就append一串messages到log中，这样消费者一次取大串数据。</p><p>This simple optimization produces orders of magnitude speed up. Batching leads to larger network packets, larger sequential disk operations, contiguous memory blocks, and so on, all of which allows Kafka to turn a bursty stream of random message writes into linear writes that flow to the consumers. 这个简单优化产生了加速。批量到了大量的网络包，大量串行磁盘操作，持续的内存block等等，这些都允许kafka转为随机消息的小的流线性写入消费者</p><p>The other inefficiency is in byte copying. At low message rates this is not an issue, but under load the impact is significant. To avoid this we employ a standardized binary message format that is shared by the producer, the broker, and the consumer (so data chunks can be transferred without modification between them).另外一个byte copying的问题，低速率消息时不时问题，但是大了不行。我们采用了二进制消息格式，producer，borker，consumer公用。</p><p>The message log maintained by the broker is itself just a directory of files, each populated by a sequence of message sets that have been written to disk in the same format used by the producer and consumer. Maintaining this common format allows optimization of the most important operation: network transfer of persistent log chunks. Modern unix operating systems offer a highly optimized code path for transferring data out of pagecache to a socket; in Linux this is done with the <a href="http://man7.org/linux/man-pages/man2/sendfile.2.html" target="_blank" rel="noopener">sendfile system call</a>. 消息日志由broker维护，是一个文件目录, 类似于message sets. 这样，现代unix提供了优化的传输pagecahge到socker，参考文献如链接。</p><p>To understand the impact of sendfile, it is important to understand the common data path for transfer of data from file to socket:</p><ol><li>The operating system reads data from the disk into pagecache in kernel space. 操作系统从磁盘上读数据到内核里的pagecache</li><li>The application reads the data from kernel space into a user-space buffer。 应用从kenerl里的pagecache到用户的buffer</li><li>The application writes the data back into kernel space into a socket buffer。 应用把数据从buffer写回kernel的page cache，并进入socket buffer</li><li>The operating system copies the data from the socket buffer to the NIC buffer where it is sent over the network。操作系统拷贝socket buffer的数据到NIC buffer，然后发送网络。</li></ol><p>This is clearly inefficient, there are four copies and two system calls. Using sendfile, this re-copying is avoided by allowing the OS to send the data from pagecache to the network directly. So in this optimized path, only the final copy to the NIC buffer is needed. re-copying可以让OS拷贝pagecache数据直接到network</p><p>We expect a common use case to be multiple consumers on a topic. Using the zero-copy optimization above, data is copied into pagecache exactly once and reused on each consumption instead of being stored in memory and copied out to user-space every time it is read. This allows messages to be consumed at a rate that approaches the limit of the network connection. 我们期望是多个用户消费一个话题，这样数据进入pagecahce一次，但是可以用多次。这基本上就让消费速度和网速的限制差不多</p><p>This combination of pagecache and sendfile means that on a Kafka cluster where the consumers are mostly caught up you will see no read activity on the disks whatsoever as they will be serving data entirely from cache. pagecache和sendfiles 意味着kafka集群中，消费者不用从磁盘上获取数据。</p><p>For more background on the sendfile and zero-copy support in Java, see this <a href="http://www.ibm.com/developerworks/linux/library/j-zerocopy" target="_blank" rel="noopener">article</a>. zero-copy支持看文章。</p><h4 id="End-to-end-Batch-Compression"><a href="#End-to-end-Batch-Compression" class="headerlink" title="End-to-end Batch Compression"></a><a href="http://kafka.apache.org/documentation/#design_compression" target="_blank" rel="noopener">End-to-end Batch Compression</a></h4><p>In some cases the bottleneck is actually not CPU or disk but network bandwidth. This is particularly true for a data pipeline that needs to send messages between data centers over a wide-area network. Of course, the user can always compress its messages one at a time without any support needed from Kafka, but this can lead to very poor compression ratios as much of the redundancy is due to repetition between messages of the same type (e.g. field names in JSON or user agents in web logs or common string values). Efficient compression requires compressing multiple messages together rather than compressing each message individually. 在某些场景不是cpu或者磁盘，而是网络带宽。特别是在数据中心在一个广阔的网络上。所以需要有效的统一压缩</p><p>Kafka supports this with an efficient batching format. A batch of messages can be clumped together compressed and sent to the server in this form. This batch of messages will be written in compressed form and will remain compressed in the log and will only be decompressed by the consumer. kafka支持有效的批处理模式。批处理消息可以一起被压缩，传输，写入log。只会被消费者解压。</p><p>Kafka supports GZIP, Snappy, LZ4 and ZStandard compression protocols. More details on compression can be found <a href="https://cwiki.apache.org/confluence/display/KAFKA/Compression" target="_blank" rel="noopener">here</a>. kafka支持gzip，snappy等等</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;效率&quot;&gt;&lt;a href=&quot;#效率&quot; class=&quot;headerlink&quot; title=&quot;效率&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://kafka.apache.org/documentation/#maximizingefficiency&quot; target=&quot;_b
      
    
    </summary>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="MQ" scheme="http://shiningstarpxx.github.com/tags/MQ/"/>
    
      <category term="Kafka" scheme="http://shiningstarpxx.github.com/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>kafka-介绍-3.md</title>
    <link href="http://shiningstarpxx.github.com/2019/04/10/kafka-%E4%BB%8B%E7%BB%8D-3/"/>
    <id>http://shiningstarpxx.github.com/2019/04/10/kafka-介绍-3/</id>
    <published>2019-04-10T12:28:41.000Z</published>
    <updated>2019-04-12T02:58:59.132Z</updated>
    
    <content type="html"><![CDATA[<h5 id="API-部分"><a href="#API-部分" class="headerlink" title="API 部分"></a><a href="http://kafka.apache.org/documentation/#api" target="_blank" rel="noopener">API 部分</a></h5><p>Kafka includes five core apis:</p><ol><li>The <a href="http://kafka.apache.org/documentation/#producerapi" target="_blank" rel="noopener">Producer</a> API allows applications to send streams of data to topics in the Kafka cluster.</li><li>The <a href="http://kafka.apache.org/documentation/#consumerapi" target="_blank" rel="noopener">Consumer</a> API allows applications to read streams of data from topics in the Kafka cluster.</li><li>The <a href="http://kafka.apache.org/documentation/#streamsapi" target="_blank" rel="noopener">Streams</a> API allows transforming streams of data from input topics to output topics.</li><li>The <a href="http://kafka.apache.org/documentation/#connectapi" target="_blank" rel="noopener">Connect</a> API allows implementing connectors that continually pull from some source system or application into Kafka or push from Kafka into some sink system or application.</li><li>The <a href="http://kafka.apache.org/documentation/#adminapi" target="_blank" rel="noopener">AdminClient</a> API allows managing and inspecting topics, brokers, and other Kafka objects.</li></ol><p>Kafka exposes all its functionality over a language independent protocol which has clients available in many programming languages. However only the Java clients are maintained as part of the main Kafka project, the others are available as independent open source projects. A list of non-Java clients is available</p><h5 id="设计"><a href="#设计" class="headerlink" title="设计"></a>设计</h5><h6 id="动机"><a href="#动机" class="headerlink" title="动机"></a><a href="http://kafka.apache.org/documentation/#majordesignelements" target="_blank" rel="noopener">动机</a></h6><p>We designed Kafka to be able to act as a unified platform for handling all the real-time data feeds <a href="http://kafka.apache.org/documentation/#introduction" target="_blank" rel="noopener">a large company might have</a>. To do this we had to think through a fairly broad set of use cases. 设计初衷就是为了满足所有的实时数据消费</p><p>It would have to have high-throughput to support high volume event streams such as real-time log aggregation. 高吞吐， 比如real-time 日志聚合</p><p>It would need to deal gracefully with large data backlogs to be able to support periodic data loads from offline systems. 需要优雅的解决离线系统周期性读取大量数据</p><p>It also meant the system would have to handle low-latency delivery to handle more traditional messaging use-cases. 必须low-latency的发送消息</p><p>We wanted to support partitioned, distributed, real-time processing of these feeds to create new, derived feeds. This motivated our partitioning and consumer model. 必须支持partitioned，分布式的，实时的处理消息。这个促使我们分区和消费者模型</p><p>Finally in cases where the stream is fed into other data systems for serving, we knew the system would have to be able to guarantee fault-tolerance in the presence of machine failures. 必须做fault-tolerance来应对机器的failures。</p><p>Supporting these uses led us to a design with a number of unique elements, more akin to a database log than a traditional messaging system. We will outline some elements of the design in the following sections.</p><h6 id="持久化，persistence"><a href="#持久化，persistence" class="headerlink" title="持久化，persistence"></a><a href="http://kafka.apache.org/documentation/#persistence" target="_blank" rel="noopener">持久化，persistence</a></h6><h4 id="Don’t-fear-the-filesystem"><a href="#Don’t-fear-the-filesystem" class="headerlink" title="Don’t fear the filesystem!"></a><a href="http://kafka.apache.org/documentation/#design_filesystem" target="_blank" rel="noopener">Don’t fear the filesystem!</a></h4><p>Kafka relies heavily on the filesystem for storing and caching messages. There is a general perception that “disks are slow” which makes people skeptical that a persistent structure can offer competitive performance. In fact disks are both much slower and much faster than people expect depending on how they are used; and a properly designed disk structure can often be as fast as the network. 合适的disk结构可以跟网络一样快！！！</p><p>The key fact about disk performance is that the throughput of hard drives has been diverging from the latency of a disk seek for the last decade. As a result the performance of linear writes on a <a href="http://en.wikipedia.org/wiki/Non-RAID_drive_architectures" target="_blank" rel="noopener">JBOD</a> configuration with six 7200rpm SATA RAID-5 array is about 600MB/sec but the performance of random writes is only about 100k/sec—a difference of over 6000X. These linear reads and writes are the most predictable of all usage patterns, and are heavily optimized by the operating system. A modern operating system provides read-ahead and write-behind techniques that prefetch data in large block multiples and group smaller logical writes into large physical writes. A further discussion of this issue can be found in this <a href="http://queue.acm.org/detail.cfm?id=1563874" target="_blank" rel="noopener">ACM Queue article</a>; they actually find that <a href="http://deliveryimages.acm.org/10.1145/1570000/1563874/jacobs3.jpg" target="_blank" rel="noopener">sequential disk access can in some cases be faster than random memory access!</a></p><p>To compensate for this performance divergence, modern operating systems have become increasingly aggressive in their use of main memory for disk caching. A modern OS will happily divert <em>all</em> free memory to disk caching with little performance penalty when the memory is reclaimed. All disk reads and writes will go through this unified cache. This feature cannot easily be turned off without using direct I/O, so even if a process maintains an in-process cache of the data, this data will likely be duplicated in OS pagecache, effectively storing everything twice. 现代操作系统都是用内存来加速磁盘，所以极端情况，内存数据同时在OS的页缓存上也有，相当于每个东西被存储了两次</p><p>Furthermore, we are building on top of the JVM, and anyone who has spent any time with Java memory usage knows two things: JVM的特性</p><ol><li>The memory overhead of objects is very high, often doubling the size of the data stored (or worse). 存储对象前的空间非常大，通常是已经存储数据大小的两倍</li><li>Java garbage collection becomes increasingly fiddly and slow as the in-heap data increases. Java的垃圾回收在堆数据增加的情况下，会变得很慢和繁琐的</li></ol><p>As a result of these factors using the filesystem and relying on pagecache is superior to maintaining an in-memory cache or other structure—we at least double the available cache by having automatic access to all free memory, and likely double again by storing a compact byte structure rather than individual objects.  直接依赖pagecache使用文件系统比在内存中使用cache或者其他数据结构更优，至少我们可以直接获得两倍大小的内存，如果使用压缩结构可以再获得两倍的空间。Doing so will result in a cache of up to 28-30GB on a 32GB machine without GC penalties. 比如，在32G的内存下cache可以达到28-30G，并且没有GC。Furthermore, this cache will stay warm even if the service is restarted, whereas the in-process cache will need to be rebuilt in memory (which for a 10GB cache may take 10 minutes) or else it will need to start with a completely cold cache (which likely means terrible initial performance). 并且，这种cache可以直接使用即使服务重启，而且内存结构需要重新构建或者重新初始化。This also greatly simplifies the code as all logic for maintaining coherency between the cache and filesystem is now in the OS, which tends to do so more efficiently and more correctly than one-off in-process attempts. If your disk usage favors linear reads then read-ahead is effectively pre-populating this cache with useful data on each disk read. 这样同样可以大幅度简化代码维护cache和文件系统一致性的问题，os可以做的更有效率更准确。</p><p>This suggests a design which is very simple: rather than maintain as much as possible in-memory and flush it all out to the filesystem in a panic when we run out of space, we invert that. All data is immediately written to a persistent log on the filesystem without necessarily flushing to disk. In effect this just means that it is transferred into the kernel’s pagecache. 这建议了一个简单的设计：与其维护一个内存结构然后再刷入磁盘， 不如所有数据写入持久化的文件系统，而不是必要时刷盘。事实上，这意味着我们把写入转化到了kernerl的pagecache.</p><p>This style of pagecache-centric design is described in an <a href="http://varnish-cache.org/wiki/ArchitectNotes" target="_blank" rel="noopener">article</a> on the design of Varnish here (along with a healthy dose of arrogance). </p><h4 id="Constant-Time-Suffices"><a href="#Constant-Time-Suffices" class="headerlink" title="Constant Time Suffices"></a><a href="http://kafka.apache.org/documentation/#design_constanttime" target="_blank" rel="noopener">Constant Time Suffices</a></h4><p>The persistent data structure used in messaging systems are often a per-consumer queue with an associated BTree or other general-purpose random access data structures to maintain metadata about messages. BTrees are the most versatile data structure available, and make it possible to support a wide variety of transactional and non-transactional semantics in the messaging system. They do come with a fairly high cost, though: Btree operations are O(log N). Normally O(log N) is considered essentially equivalent to constant time, but this is not true for disk operations. Disk seeks come at 10 ms a pop, and each disk can do only one seek at a time so parallelism is limited. Hence even a handful of disk seeks leads to very high overhead. Since storage systems mix very fast cached operations with very slow physical disk operations, the observed performance of tree structures is often superlinear as data increases with fixed cache–i.e. doubling your data makes things much worse than twice as slow. 传统的BTree的 O(log N)在磁盘下不适合。</p><p>Intuitively a persistent queue could be built on simple reads and appends to files as is commonly the case with logging solutions. This structure has the advantage that all operations are O(1) and reads do not block writes or each other. This has obvious performance advantages since the performance is completely decoupled from the data size—one server can now take full advantage of a number of cheap, low-rotational speed 1+TB SATA drives. Though they have poor seek performance, these drives have acceptable performance for large reads and writes and come at 1/3 the price and 3x the capacity. logging的解决方案，大概是1/3的价格，3倍的容量。</p><p>Having access to virtually unlimited disk space without any performance penalty means that we can provide some features not usually found in a messaging system. For example, in Kafka, instead of attempting to delete messages as soon as they are consumed, we can retain messages for a relatively long period (say a week). This leads to a great deal of flexibility for consumers, as we will describe. 这种方案可以提供传统消息系统无法提供的优势。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h5 id=&quot;API-部分&quot;&gt;&lt;a href=&quot;#API-部分&quot; class=&quot;headerlink&quot; title=&quot;API 部分&quot;&gt;&lt;/a&gt;&lt;a href=&quot;http://kafka.apache.org/documentation/#api&quot; target=&quot;_blank&quot;
      
    
    </summary>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="MQ" scheme="http://shiningstarpxx.github.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>kafka-介绍-2</title>
    <link href="http://shiningstarpxx.github.com/2019/04/06/kafka-%E4%BB%8B%E7%BB%8D-2/"/>
    <id>http://shiningstarpxx.github.com/2019/04/06/kafka-介绍-2/</id>
    <published>2019-04-06T07:12:10.000Z</published>
    <updated>2019-04-06T09:03:16.984Z</updated>
    
    <content type="html"><![CDATA[<h3 id="上文回顾"><a href="#上文回顾" class="headerlink" title="上文回顾"></a>上文回顾</h3><p>上一篇介绍了kafka基本的组成和功能，同时介绍了生产-消费的过程，以及简单描述了kafka的replication等等概念性的。这一篇还是概念性的，结合kafka官方文档学习。</p><h3 id="Multi-tenancy-多租约"><a href="#Multi-tenancy-多租约" class="headerlink" title="Multi-tenancy 多租约"></a>Multi-tenancy 多租约</h3><p>You can deploy Kafka as a multi-tenant solution. Multi-tenancy is enabled by configuring which topics can produce or consume data. There is also operations support for quotas. Administrators can define and enforce quotas on requests to control the broker resources that are used by clients. For more information, see the <a href="https://kafka.apache.org/documentation/#security" target="_blank" rel="noopener">security documentation</a>. 多组约问题放到后面再深入研究 @TODO</p><h3 id="Garantees"><a href="#Garantees" class="headerlink" title="Garantees"></a>Garantees</h3><p>At a high-level Kafka gives the following guarantees: kafka保证下面的</p><ul><li>Messages sent by a producer to a particular topic partition will be appended in the order they are sent. That is, if a record M1 is sent by the same producer as a record M2, and M1 is sent first, then M1 will have a lower offset than M2 and appear earlier in the log. 在同一个topic内，一个生产者产生的record有序.</li><li>A consumer instance sees records in the order they are stored in the log. 消费者看到是有序的</li><li>For a topic with replication factor N, we will tolerate up to N-1 server failures without losing any records committed to the log. 如果replication的参数是N，那么最多容忍N-1的服务失败但是不丢数据</li></ul><p>More details on these guarantees are given in the design section of the documentation.</p><h3 id="KafKa-As-a-messaging-System-kafka作为消息系统"><a href="#KafKa-As-a-messaging-System-kafka作为消息系统" class="headerlink" title="KafKa As a messaging System kafka作为消息系统"></a>KafKa As a messaging System <a href="http://kafka.apache.org/documentation/#kafka_mq" target="_blank" rel="noopener">kafka作为消息系统</a></h3><p>How does Kafka’s notion of streams compare to a traditional enterprise messaging system? Kafka 与传统的消息系统的对比</p><p>Messaging traditionally has two models: <a href="http://en.wikipedia.org/wiki/Message_queue" target="_blank" rel="noopener">queuing</a> and <a href="http://en.wikipedia.org/wiki/Publish%E2%80%93subscribe_pattern" target="_blank" rel="noopener">publish-subscribe</a>. In a queue, a pool of consumers may read from a server and each record goes to one of them; in publish-subscribe the record is broadcast to all consumers. Each of these two models has a strength and a weakness. The strength of queuing is that it allows you to divide up the processing of data over multiple consumer instances, which lets you scale your processing. Unfortunately, queues aren’t multi-subscriber—once one process reads the data it’s gone. Publish-subscribe allows you broadcast data to multiple processes, but has no way of scaling processing since every message goes to every subscriber. 传统的消息有两种模型：<strong>队列</strong>和<strong>“发布-订阅”</strong>。在queue种，消费池可以从一个server上读，每个记录会被一个消费者消费；在发布-订阅模式，记录广播给所有的消费者。 两种模型各有优劣。 queue的优点是可以让记录在不同的消费者之间分配，可以scale。但是不幸的是，queue不能多订阅者，数据一读就消失了。发布-订阅可以广播消息到不同进程，但是在不同进程间无法scale，因为每个消息都会发给不同进程。</p><p>The consumer group concept in Kafka generalizes these two concepts. As with a queue the consumer group allows you to divide up processing over a collection of processes (the members of the consumer group). As with publish-subscribe, Kafka allows you to broadcast messages to multiple consumer groups. Kafka 融合了这两个概念，消费组里可以共享一组消息，不同组之间消息是独立的。</p><p>The advantage of Kafka’s model is that every topic has both these properties—it can scale processing and is also multi-subscriber—there is no need to choose one or the other. kafka模型保证了process可以scale，同时支持多订阅者。</p><p>Kafka has stronger ordering guarantees than a traditional messaging system, too. kafka保证了更强的顺序性</p><p>A traditional queue retains records in-order on the server, and if multiple consumers consume from the queue then the server hands out records in the order they are stored. However, although the server hands out records in order, the records are delivered asynchronously to consumers, so they may arrive out of order on different consumers. This effectively means the ordering of the records is lost in the presence of parallel consumption. Messaging systems often work around this by having a notion of “exclusive consumer” that allows only one process to consume from a queue, but of course this means that there is no parallelism in processing. queue的模型保证了server存储数据的顺序性，但是不能保证消费者的顺序性。</p><p>Kafka does it better. By having a notion of parallelism—the partition—within the topics, Kafka is able to provide both ordering guarantees and load balancing over a pool of consumer processes. This is achieved by assigning the partitions in the topic to the consumers in the consumer group so that each partition is consumed by exactly one consumer in the group. By doing this we ensure that the consumer is the only reader of that partition and consumes the data in order. Since there are many partitions this still balances the load over many consumer instances. Note however that there cannot be more consumer instances in a consumer group than partitions. kafka同时保证了顺序性和消费组内的平衡。在一个消费组内，kafka只要每个partition分配一个消费者就可以保证顺序性，和scale。但是kafka消费组内最大的consumer数量就是分片的数量</p><h3 id="Kafka作为存储系统"><a href="#Kafka作为存储系统" class="headerlink" title="Kafka作为存储系统"></a>Kafka作为存储系统</h3><p>Any message queue that allows publishing messages decoupled from consuming them is effectively acting as a storage system for the in-flight messages. What is different about Kafka is that it is a very good storage system.</p><p>Data written to Kafka is written to disk and replicated for fault-tolerance. Kafka allows producers to wait on acknowledgement so that a write isn’t considered complete until it is fully replicated and guaranteed to persist even if the server written to fails. kafka写数据为了fault-tolerance做了replication</p><p>The disk structures Kafka uses scale well—Kafka will perform the same whether you have 50 KB or 50 TB of persistent data on the server. kafka对disk也做了scale考虑</p><p>As a result of taking storage seriously and allowing the clients to control their read position, you can think of Kafka as a kind of special purpose distributed filesystem dedicated to high-performance, low-latency commit log storage, replication, and propagation. kafka可以认为是为了特定目的的分布式文件系统，满足high-performance，low-latency, commit log storage, replication and propagation.</p><p>For details about the Kafka’s commit log storage and replication design, please read <a href="https://kafka.apache.org/documentation/#design" target="_blank" rel="noopener">this</a> page.</p><h3 id="Kafka-作为streaming-system"><a href="#Kafka-作为streaming-system" class="headerlink" title="Kafka 作为streaming system"></a>Kafka 作为streaming system</h3><p>It isn’t enough to just read, write, and store streams of data, the purpose is to enable real-time processing of streams.</p><p>In Kafka a stream processor is anything that takes continual streams of data from input topics, performs some processing on this input, and produces continual streams of data to output topics. 针对流式系统</p><p>For example, a retail application might take in input streams of sales and shipments, and output a stream of reorders and price adjustments computed off this data. 比如sales，货运信息， 会使订单调整&amp;price调整 .</p><p>It is possible to do simple processing directly using the producer and consumer APIs. However for more complex transformations Kafka provides a fully integrated <a href="http://kafka.apache.org/documentation/streams" target="_blank" rel="noopener">Streams API</a>. This allows building applications that do non-trivial processing that compute aggregations off of streams or join streams together.</p><p>This facility helps solve the hard problems this type of application faces: handling out-of-order data, reprocessing input as code changes, performing stateful computations, etc. 解决乱序数据，代码更新后重新计算，做状态计算等等能力</p><p>The streams API builds on the core primitives Kafka provides: it uses the producer and consumer APIs for input, uses Kafka for stateful storage, and uses the same group mechanism for fault tolerance among the stream processor instances.</p><h3 id="kafka综合能力"><a href="#kafka综合能力" class="headerlink" title="kafka综合能力"></a>kafka综合能力</h3><p>This combination of messaging, storage, and stream processing may seem unusual but it is essential to Kafka’s role as a streaming platform. 虽然支持消息，存储，流处理，但是核心还是流处理平台</p><p>A distributed file system like HDFS allows storing static files for batch processing. Effectively a system like this allows storing and processing <em>historical</em> data from the past. 分布式文件hdfs支持处理历史数据-batch</p><p>A traditional enterprise messaging system allows processing future messages that will arrive after you subscribe. Applications built in this way process future data as it arrives. 传统企业消息系统允许处理随时订阅，支持任何时候消息到达。</p><p>Kafka combines both of these capabilities, and the combination is critical both for Kafka usage as a platform for streaming applications as well as for streaming data pipelines. kafka既是streaming application的platform又是streaming data的pipelines</p><p>By combining storage and low-latency subscriptions, streaming applications can treat both past and future data the same way. That is a single application can process historical, stored data but rather than ending when it reaches the last record it can keep processing as future data arrives. This is a generalized notion of stream processing that subsumes batch processing as well as message-driven applications. 结合了low-latency和streaming application，可以统一处理过去和未来的数据，也就是说可以作为batch处理也可以作为message-driven应用。</p><p>Likewise for streaming data pipelines the combination of subscription to real-time events make it possible to use Kafka for very low-latency pipelines; but the ability to store data reliably make it possible to use it for critical data where the delivery of data must be guaranteed or for integration with offline systems that load data only periodically or may go down for extended periods of time for maintenance. The stream processing facilities make it possible to transform data as it arrives. 同时是低时延，还支持容灾存储关键数据</p><p>For more information on the guarantees, APIs, and capabilities Kafka provides see the rest of the <a href="http://kafka.apache.org/documentation.html" target="_blank" rel="noopener">documentation</a>.</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>参考 <a href="http://kafka.apache.org/documentation/#introduction" target="_blank" rel="noopener">Apache Kafka 首页，了解最全面的 Apache Kafka 知识</a></li><li></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;上文回顾&quot;&gt;&lt;a href=&quot;#上文回顾&quot; class=&quot;headerlink&quot; title=&quot;上文回顾&quot;&gt;&lt;/a&gt;上文回顾&lt;/h3&gt;&lt;p&gt;上一篇介绍了kafka基本的组成和功能，同时介绍了生产-消费的过程，以及简单描述了kafka的replication等等概念
      
    
    </summary>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="MQ" scheme="http://shiningstarpxx.github.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>kafka 介绍 — 1</title>
    <link href="http://shiningstarpxx.github.com/2019/04/05/kafka-%E4%BB%8B%E7%BB%8D/"/>
    <id>http://shiningstarpxx.github.com/2019/04/05/kafka-介绍/</id>
    <published>2019-04-05T13:10:05.000Z</published>
    <updated>2019-04-06T09:03:34.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独立地执行–它们不需要知道彼此的位置、或在继续执行前不需要等待接收程序接收此消息。在分布式计算环境中，为了集成分布式应用，开发者需要对异构网络环境下的分布式应用提供有效的通信手段。为了管理需要共享的信息，对应用提供公共的信息交换机制是重要的。常用的消息队列技术是 Message Queue。</p><h3 id="从不同的角度来看kafka-MQ"><a href="#从不同的角度来看kafka-MQ" class="headerlink" title="从不同的角度来看kafka(MQ)"></a>从不同的角度来看kafka(MQ)</h3><p>A streaming platform has three key capabilities:  (三个关键能力)</p><ul><li>Publish and subscribe to streams of records, similar to a message queue or enterprise messaging system. (发布和订阅)</li><li>Store streams of records in a fault-tolerant durable way. (持久化存储)</li><li>Process streams of records as they occur. (顺序保证)</li></ul><p>Kafka is generally used for two broad classes of applications: (解决两大类问题)</p><ul><li>Building real-time streaming data pipelines that reliably get data between systems or applications — 实时数据流通道</li><li>Building real-time streaming applications that transform or react to the streams of data —  实时数据转换或者响应处理</li></ul><h3 id="kafka基本概念"><a href="#kafka基本概念" class="headerlink" title="kafka基本概念"></a>kafka基本概念</h3><p>First a few concepts: </p><ul><li>Kafka is run as a cluster on one or more servers that can span multiple datacenters.   — 可以跨数据中心</li><li>The Kafka cluster stores streams of <em>records</em> in categories called <em>topics</em>. — 聚类的数据流成为一个topic</li><li>Each record consists of a key, a value, and a timestamp. — 每条记录都有key，value和timestamp</li></ul><p>Kafka has four core APIs:  — 4 个核心api</p><ul><li>The <a href="http://kafka.apache.org/documentation.html#producerapi" target="_blank" rel="noopener">Producer API</a> allows an application to publish a stream of records to one or more Kafka topics. 生产者</li><li>The <a href="http://kafka.apache.org/documentation.html#consumerapi" target="_blank" rel="noopener">Consumer API</a> allows an application to subscribe to one or more topics and process the stream of records produced to them. 消费者</li><li>The <a href="http://kafka.apache.org/documentation/streams" target="_blank" rel="noopener">Streams API</a> allows an application to act as a <em>stream processor</em>, consuming an input stream from one or more topics and producing an output stream to one or more output topics, effectively transforming the input streams to output streams. 流式api</li><li>The <a href="http://kafka.apache.org/documentation.html#connect" target="_blank" rel="noopener">Connector API</a> allows building and running reusable producers or consumers that connect Kafka topics to existing applications or data systems. For example, a connector to a relational database might capture every change to a table. 连接者？</li></ul><p>Kafka API图如下所示</p><p><img src="http://kafka.apache.org/22/images/kafka-apis.png" alt="kafka的API组成"></p><h3 id="Topics-and-Logs"><a href="#Topics-and-Logs" class="headerlink" title="Topics and Logs"></a>Topics and Logs</h3><p>A topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it.</p><p>在广告业务中，比较典型的使用是，request是一个大的topic，还有广告相关曝光，点击日志等分别是不同的topic。</p><p>For each topic, the Kafka cluster maintains a partitioned log that looks like this: (一个topic会有多个partition，对于请求日志来说，因为太大了，所以一定有分片)</p><p><img src="http://kafka.apache.org/22/images/log_anatomy.png" alt></p><p>Each partition is an ordered, immutable sequence of records that is continually appended to—a structured commit log. The records in the partitions are each assigned a sequential id number called the <em>offset</em> that uniquely identifies each record within the partition. 每一个分片里都是顺序的，不可修改的，这样做也是为了性能，update是一个非常耗时的操作.</p><p>The Kafka cluster durably persists all published records—whether or not they have been consumed—using a configurable retention period. For example, if the retention policy is set to two days, then for the two days after a record is published, it is available for consumption, after which it will be discarded to free up space. Kafka’s performance is effectively constant with respect to data size so storing data for a long time is not a problem. kafka可以根据设置的时间做持久化存储，性能和数据大小也是常数关系，对数据增长不敏感。</p><p><img src="http://kafka.apache.org/22/images/log_consumer.png" alt></p><p>In fact, the only metadata retained on a per-consumer basis is the offset or position of that consumer in the log. This offset is controlled by the consumer: normally a consumer will advance its offset linearly as it reads records, but, in fact, since the position is controlled by the consumer it can consume records in any order it likes. For example a consumer can reset to an older offset to reprocess data from the past or skip ahead to the most recent record and start consuming from “now”. 跟comsumer相关的只有metadata，并且可以由consumer随意修改控制</p><p>This combination of features means that Kafka consumers are very cheap—they can come and go without much impact on the cluster or on other consumers. For example, you can use our command line tools to “tail” the contents of any topic without changing what is consumed by any existing consumers. 这种相结合的设计（kafka维护metadata，consumer负责控制），可以说兼顾了灵活和高效。另外的一种设计方式，是meta data由consumer来存储和控制–RabbitMQ？</p><p>The partitions in the log serve several purposes. First, they allow the log to scale beyond a size that will fit on a single server. Each individual partition must fit on the servers that host it, but a topic may have many partitions so it can handle an arbitrary amount of data. Second they act as the unit of parallelism—more on that in a bit. partiion分区是为了增加topic的容量和吞吐量</p><h3 id="Distribution分布式"><a href="#Distribution分布式" class="headerlink" title="Distribution分布式"></a>Distribution分布式</h3><p>The partitions of the log are distributed over the servers in the Kafka cluster with each server handling data and requests for a share of the partitions. Each partition is replicated across a configurable number of servers for fault tolerance. log的分片是分布式的，replicated数量也是根据配置来设置</p><p>Each partition has one server which acts as the “leader” and zero or more servers which act as “followers”. The leader handles all read and write requests for the partition while the followers passively replicate the leader. If the leader fails, one of the followers will automatically become the new leader. Each server acts as a leader for some of its partitions and a follower for others so load is well balanced within the cluster. 每个分片一定会有一个leader，0个或者多个followers。leader负责读写，followers是负责replicate。如果leader挂了，一个follower会自动成为新的leader。每个服务可以做几个分片的leader，也可以做其他几个分片的follower，来实现load balance。(这也是因为replicate决定了一个server会有多个partition，作为容灾)</p><h3 id="Geo-Replication"><a href="#Geo-Replication" class="headerlink" title="Geo-Replication"></a>Geo-Replication</h3><p>Kafka MirrorMaker provides geo-replication support for your clusters. With MirrorMaker, messages are replicated across multiple datacenters or cloud regions. You can use this in active/passive scenarios for backup and recovery; or in active/active scenarios to place data closer to your users, or support data locality requirements. 可以跨地域备份，主动&amp;被动都可以</p><h3 id="Producers-生产者"><a href="#Producers-生产者" class="headerlink" title="Producers 生产者"></a>Producers 生产者</h3><p>Producers publish data to the topics of their choice. The producer is responsible for choosing which record to assign to which partition within the topic. This can be done in a round-robin fashion simply to balance load or it can be done according to some semantic partition function (say based on some key in the record). More on the use of partitioning in a second! 生产者要保证均匀-平衡的写入同一个topic的分片中</p><h3 id="Consumers-消费者"><a href="#Consumers-消费者" class="headerlink" title="Consumers 消费者"></a>Consumers 消费者</h3><p>Consumers label themselves with a <em>consumer group</em> name, and each record published to a topic is delivered to one consumer instance within each subscribing consumer group. Consumer instances can be in separate processes or on separate machines. 消费者有消费组的概念，在一个消费组内，一个记录只能被一个消费者消费。消费者实例可以是不同的进程，也可以在不同的机器上</p><p>If all the consumer instances have the same consumer group, then the records will effectively be load balanced over the consumer instances. 同一个组内的消费者会balanced的消费records</p><p>If all the consumer instances have different consumer groups, then each record will be broadcast to all the consumer processes. 每个record会广播给不同消费者组</p><p><img src="http://kafka.apache.org/22/images/consumer-groups.png" alt></p><p>A two server Kafka cluster hosting four partitions (P0-P3) with two consumer groups. Consumer group A has two consumer instances and group B has four. 如上图所示，4个分片，两个消费组</p><p>More commonly, however, we have found that topics have a small number of consumer groups, one for each “logical subscriber”. Each group is composed of many consumer instances for scalability and fault tolerance. This is nothing more than publish-subscribe semantics where the subscriber is a cluster of consumers instead of a single process. 通常我们观察到，每个话题通常是有少数几个消费组，每个表示一个逻辑上的订阅。每个组由几个消费实例用于scalability和容错。这个语义也是包含发布-订阅</p><p>The way consumption is implemented in Kafka is by dividing up the partitions in the log over the consumer instances so that each instance is the exclusive consumer of a “fair share” of partitions at any point in time. This process of maintaining membership in the group is handled by the Kafka protocol dynamically. If new instances join the group they will take over some partitions from other members of the group; if an instance dies, its partitions will be distributed to the remaining instances. kafka的实现是基于log分配给消费实例，这样每个实例可以在任意时间点”公平”的消费。消费实例的平衡由kafka内部实现。如果新的加入，会从其他人身上分担一些，如果一个挂掉，会分给其他人。—看起来很像是一致性哈希保证的。</p><p>Kafka only provides a total order over records <em>within</em> a partition, not between different partitions in a topic. Per-partition ordering combined with the ability to partition data by key is sufficient for most applications. However, if you require a total order over records this can be achieved with a topic that has only one partition, though this will mean only one consumer process per consumer group. kafka只能保证同一个topic的同一个partition内有序。如果需要topic强有序，只能有一个分片，这样会导致只能有一个消费实例在一个消费组里。</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><ul><li>参考 <a href="http://kafka.apache.org/" target="_blank" rel="noopener">Apache Kafka 首页，了解最全面的 Apache Kafka 知识。</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-kafka/index.html" target="_blank" rel="noopener">Apache kafka 工作原理介绍</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;消息队列技术是分布式应用间交换信息的一种技术。消息队列可驻留在内存或磁盘上, 队列存储消息直到它们被应用程序读走。通过消息队列，应用程序可独
      
    
    </summary>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="MQ" scheme="http://shiningstarpxx.github.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>linux使用zsh</title>
    <link href="http://shiningstarpxx.github.com/2019/04/04/linux%E4%BD%BF%E7%94%A8zsh/"/>
    <id>http://shiningstarpxx.github.com/2019/04/04/linux使用zsh/</id>
    <published>2019-04-04T11:29:53.000Z</published>
    <updated>2019-04-04T11:35:59.373Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>shell目前主流是/bin/bash, 但是配色真丑。业界里提供了很多更好的bash，比如叫zsh。 在mac上和linux上我都安装了zsh</p><h5 id="1-安装zsh包"><a href="#1-安装zsh包" class="headerlink" title="1.安装zsh包"></a>1.安装zsh包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install zsh</span><br></pre></td></tr></table></figure><h5 id="2-切换默认shell为zsh"><a href="#2-切换默认shell为zsh" class="headerlink" title="2.切换默认shell为zsh"></a>2.切换默认shell为zsh</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chsh -s /bin/zsh</span><br></pre></td></tr></table></figure><h5 id="3-重启服务器让修改的配置生效"><a href="#3-重启服务器让修改的配置生效" class="headerlink" title="3.重启服务器让修改的配置生效"></a>3.重启服务器让修改的配置生效</h5><p>这个没什么好多说的，我习惯在web端控制台直接重启。</p><h5 id="4-安装on-my-zsh"><a href="#4-安装on-my-zsh" class="headerlink" title="4.安装on my zsh"></a>4.安装on my zsh</h5><p>curl<br><code>sh -c &quot;$(curl -fsSL https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh)&quot;</code><br>wget<br><code>sh -c &quot;$(wget https://raw.githubusercontent.com/robbyrussell/oh-my-zsh/master/tools/install.sh -O -)&quot;</code></p><p>实际上到这一步oh my zsh就已经安装完成了。</p><h5 id="5-最后调整theme"><a href="#5-最后调整theme" class="headerlink" title="5. 最后调整theme"></a>5. 最后调整theme</h5><p>使用ys主题 </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;shell目前主流是/bin/bash, 但是配色真丑。业界里提供了很多更好的bash，比如叫zsh。 在mac上和linux上我都安装了z
      
    
    </summary>
    
    
      <category term="linux, bash" scheme="http://shiningstarpxx.github.com/tags/linux-bash/"/>
    
  </entry>
  
  <entry>
    <title>Apache Kafka Installation on Mac using Homebrew</title>
    <link href="http://shiningstarpxx.github.com/2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/"/>
    <id>http://shiningstarpxx.github.com/2019/04/03/Apache-Kafka-Installation-on-Mac-using-Homebrew/</id>
    <published>2019-04-03T14:08:08.000Z</published>
    <updated>2019-04-10T06:48:26.428Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>学习大数据，离不开kafka，mac os上就得装一个。安装步骤如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ brew cask install java</span><br><span class="line">$ brew install kafka</span><br></pre></td></tr></table></figure><h4 id="启动zookeeper"><a href="#启动zookeeper" class="headerlink" title="启动zookeeper"></a>启动zookeeper</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ zookeeper-server-start /usr/<span class="built_in">local</span>/etc/kafka/zookeeper.properties</span><br></pre></td></tr></table></figure><h4 id="启动kafka-server"><a href="#启动kafka-server" class="headerlink" title="启动kafka server"></a>启动kafka server</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-server-start /usr/<span class="built_in">local</span>/etc/kafka/server.properties</span><br></pre></td></tr></table></figure><h4 id="开始验证"><a href="#开始验证" class="headerlink" title="开始验证"></a>开始验证</h4><h5 id="创建kafka-topic"><a href="#创建kafka-topic" class="headerlink" title="创建kafka topic"></a>创建kafka topic</h5><p><em>A topic is a category or feed name to which records are published. Topics in Kafka are always multi-subscriber; that is, a topic can have zero, one, or many consumers that subscribe to the data written to it.</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kafka-topics --create --zookeeper localhost:2181 --replication-factor 1 --partitions 1 --topic <span class="built_in">test</span></span><br></pre></td></tr></table></figure><h5 id="Initialize-Producer-console"><a href="#Initialize-Producer-console" class="headerlink" title="Initialize Producer console"></a>Initialize Producer console</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-producer --broker-list localhost:9092 --topic <span class="built_in">test</span></span><br><span class="line">&gt;send first message</span><br><span class="line">&gt;send second message</span><br><span class="line">&gt;wow it is working</span><br></pre></td></tr></table></figure><h5 id="Initialize-Consumer-console"><a href="#Initialize-Consumer-console" class="headerlink" title="Initialize Consumer console"></a>Initialize Consumer console</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">kafka-console-consumer --bootstrap-server localhost:9092 --topic <span class="built_in">test</span> --from-beginning</span><br><span class="line">send first message</span><br><span class="line">send second message</span><br><span class="line">wow it is working</span><br></pre></td></tr></table></figure><h5 id="列出所有的topic"><a href="#列出所有的topic" class="headerlink" title="列出所有的topic"></a>列出所有的topic</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics --list --zookeeper localhost:2181</span><br></pre></td></tr></table></figure><h5 id="查看topic的状态"><a href="#查看topic的状态" class="headerlink" title="查看topic的状态"></a>查看topic的状态</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics --describe --zookeeper localhost:2181 --topic <span class="built_in">test</span></span><br><span class="line">Topic:<span class="built_in">test</span>PartitionCount:1ReplicationFactor:1Configs:</span><br><span class="line">Topic: <span class="built_in">test</span>Partition: 0Leader: 0Replicas: 0Isr: 0</span><br></pre></td></tr></table></figure><ul><li><p>“leader” is the node responsible for all reads and writes for the given partition. Each node will be the leader for a randomly selected portion of the partitions.</p></li><li><p>“replicas” is the list of nodes that replicate the log for this partition regardless of whether they are the leader or even if they are currently alive.</p></li><li><p>“isr” is the set of “in-sync” replicas. This is the subset of the replicas list that is currently alive and caught-up to the leader.</p></li></ul><h5 id="尝试做多个备份"><a href="#尝试做多个备份" class="headerlink" title="尝试做多个备份"></a>尝试做多个备份</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ kafka-topics --create --zookeeper localhost:2181 --replication-factor 3 --partitions 1 --topic multi-test</span><br><span class="line">Error <span class="keyword">while</span> executing topic <span class="built_in">command</span> : Replication factor: 3 larger than available brokers: 1.</span><br><span class="line">[2019-04-10 10:04:28,763] ERROR org.apache.kafka.common.errors.InvalidReplicationFactorException: Replication factor: 3 larger than available brokers: 1.</span><br><span class="line"> (kafka.admin.TopicCommand$)</span><br></pre></td></tr></table></figure><p>发现报错，原因是我们起的broker只有一个，需要多起几个broker</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;学习大数据，离不开kafka，mac os上就得装一个。安装步骤如下&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;
      
    
    </summary>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="MQ" scheme="http://shiningstarpxx.github.com/tags/MQ/"/>
    
  </entry>
  
  <entry>
    <title>部署elk</title>
    <link href="http://shiningstarpxx.github.com/2019/04/02/%E9%83%A8%E7%BD%B2elk/"/>
    <id>http://shiningstarpxx.github.com/2019/04/02/部署elk/</id>
    <published>2019-04-02T12:39:24.000Z</published>
    <updated>2019-04-03T02:50:54.795Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>elk已经成为了业界的标准日志分析系统，这里在mac os上做了一些测试验证, 这里方便以后查询，把操作过程做了记录.</p><h3 id="Installing-Elasticsearch"><a href="#Installing-Elasticsearch" class="headerlink" title="Installing Elasticsearch"></a>Installing Elasticsearch</h3><p>Now that we’ve made sure our system and environment have the required pieces in place, we can begin with installing the stack’s components, starting with Elasticsearch:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install elasticsearch &amp;&amp; brew info elasticsearch</span><br><span class="line">brew services start elasticsearch</span><br></pre></td></tr></table></figure><p>Use your favorite browser to check that it is running correctly on localhost and the default port: <em><a href="http://localhost:9200" target="_blank" rel="noopener">http://localhost:9200</a></em></p><p>The output should look something like this:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span> : <span class="string">"FH0SVRp"</span>,</span><br><span class="line">  <span class="attr">"cluster_name"</span> : <span class="string">"elasticsearch_peixingxin"</span>,</span><br><span class="line">  <span class="attr">"cluster_uuid"</span> : <span class="string">"7uVXslqeQ_al6pZA2p0AGQ"</span>,</span><br><span class="line">  <span class="attr">"version"</span> : &#123;</span><br><span class="line">    <span class="attr">"number"</span> : <span class="string">"6.7.0"</span>,</span><br><span class="line">    <span class="attr">"build_flavor"</span> : <span class="string">"oss"</span>,</span><br><span class="line">    <span class="attr">"build_type"</span> : <span class="string">"tar"</span>,</span><br><span class="line">    <span class="attr">"build_hash"</span> : <span class="string">"8453f77"</span>,</span><br><span class="line">    <span class="attr">"build_date"</span> : <span class="string">"2019-03-21T15:32:29.844721Z"</span>,</span><br><span class="line">    <span class="attr">"build_snapshot"</span> : <span class="literal">false</span>,</span><br><span class="line">    <span class="attr">"lucene_version"</span> : <span class="string">"7.7.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_wire_compatibility_version"</span> : <span class="string">"5.6.0"</span>,</span><br><span class="line">    <span class="attr">"minimum_index_compatibility_version"</span> : <span class="string">"5.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"tagline"</span> : <span class="string">"You Know, for Search"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Installing-Logstash"><a href="#Installing-Logstash" class="headerlink" title="Installing Logstash"></a>Installing Logstash</h3><p>Your next step is to install Logstash:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew install logstash</span><br><span class="line">brew services start logstash</span><br></pre></td></tr></table></figure><h3 id="Installing-Kibana"><a href="#Installing-Kibana" class="headerlink" title="Installing Kibana"></a>Installing Kibana</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">brew install kibana</span><br><span class="line">brew services start kibana</span><br><span class="line">brew services list</span><br></pre></td></tr></table></figure><p>Open the Kibana configuration file:  <em>kibana.yml</em></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vi /usr/<span class="built_in">local</span>/etc/kibana/kibana.yml</span><br></pre></td></tr></table></figure><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">server.port:</span> <span class="number">5601</span></span><br><span class="line"><span class="string">elasticsearch.url:</span> <span class="string">"http://localhost:9200”</span></span><br></pre></td></tr></table></figure><p>If everything went well, open Kibana at <a href="http://localhost:5601/status" target="_blank" rel="noopener">http://localhost:5601/status</a>. You should see something like this:</p><h3 id="Shipping-some-data"><a href="#Shipping-some-data" class="headerlink" title="Shipping some data"></a>Shipping some data</h3><p>You are ready to start sending data into Elasticsearch and enjoy all the goodness that the stack offers. To help you get started, here is an example of a Logstash pipeline sending syslog logs into the stack.</p><p>First, you will need to create a new Logstash configuration file: 同时要在配置文件中增加该路径</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo vim //user/<span class="built_in">local</span>/etc/logstash/syslog.conf</span><br></pre></td></tr></table></figure><p>Enter the following configuration:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">input</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">file</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">path</span> <span class="string">=&gt;</span> <span class="string">[</span> <span class="string">"/var/log/*.log"</span><span class="string">,</span> <span class="string">"/var/log/messages"</span><span class="string">,</span> <span class="string">"/var/log/syslog"</span> <span class="string">]</span></span><br><span class="line">    <span class="string">type</span> <span class="string">=&gt;</span> <span class="string">"syslog"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">filter</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">if</span> <span class="string">[type]</span> <span class="string">==</span> <span class="string">"syslog"</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">grok</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">match</span> <span class="string">=&gt;</span> <span class="string">&#123;</span> <span class="string">"message"</span> <span class="string">=&gt;</span> <span class="string">"<span class="template-variable">%&#123;SYSLOGTIMESTAMP:syslog_timestamp&#125;</span> <span class="template-variable">%&#123;SYSLOGHOST:syslog_hostname&#125;</span> <span class="template-variable">%&#123;DATA:syslog_program&#125;</span>(?:\[<span class="template-variable">%&#123;POSINT:syslog_pid&#125;</span>\])?: <span class="template-variable">%&#123;GREEDYDATA:syslog_message&#125;</span>"</span> <span class="string">&#125;</span></span><br><span class="line">      <span class="string">add_field</span> <span class="string">=&gt;</span> <span class="string">[</span> <span class="string">"received_at"</span><span class="string">,</span> <span class="string">"<span class="template-variable">%&#123;@timestamp&#125;</span>"</span> <span class="string">]</span></span><br><span class="line">      <span class="string">add_field</span> <span class="string">=&gt;</span> <span class="string">[</span> <span class="string">"received_from"</span><span class="string">,</span> <span class="string">"<span class="template-variable">%&#123;host&#125;</span>"</span> <span class="string">]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">    <span class="string">syslog_pri</span> <span class="string">&#123;</span> <span class="string">&#125;</span></span><br><span class="line">    <span class="string">date</span> <span class="string">&#123;</span></span><br><span class="line">      <span class="string">match</span> <span class="string">=&gt;</span> <span class="string">[</span> <span class="string">"syslog_timestamp"</span><span class="string">,</span> <span class="string">"MMM  d HH:mm:ss"</span><span class="string">,</span> <span class="string">"MMM dd HH:mm:ss"</span> <span class="string">]</span></span><br><span class="line">    <span class="string">&#125;</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"> </span><br><span class="line"><span class="string">output</span> <span class="string">&#123;</span></span><br><span class="line">  <span class="string">elasticsearch</span> <span class="string">&#123;</span></span><br><span class="line">    <span class="string">hosts</span> <span class="string">=&gt;</span> <span class="string">["127.0.0.1:9200"]</span> </span><br><span class="line">    <span class="string">index</span> <span class="string">=&gt;</span> <span class="string">"syslog-demo"</span></span><br><span class="line">  <span class="string">&#125;</span></span><br><span class="line">  <span class="string">stdout</span> <span class="string">&#123;</span> <span class="string">codec</span> <span class="string">=&gt;</span> <span class="string">rubydebug</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew services restart logstash</span><br></pre></td></tr></table></figure><p>In the Management tab in Kibana, you should see a newly created “syslog-demo” index created by the new Logstash pipeline.</p><h4 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h4><p><a href="https://logz.io/blog/elk-mac/" target="_blank" rel="noopener">网上比较好的文档</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;elk已经成为了业界的标准日志分析系统，这里在mac os上做了一些测试验证, 这里方便以后查询，把操作过程做了记录.&lt;/p&gt;
&lt;h3 id
      
    
    </summary>
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/categories/StreamingSystem/"/>
    
    
      <category term="StreamingSystem" scheme="http://shiningstarpxx.github.com/tags/StreamingSystem/"/>
    
      <category term="elk" scheme="http://shiningstarpxx.github.com/tags/elk/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="http://shiningstarpxx.github.com/2017/10/28/hello-world/"/>
    <id>http://shiningstarpxx.github.com/2017/10/28/hello-world/</id>
    <published>2017-10-28T00:39:58.000Z</published>
    <updated>2017-10-28T00:39:58.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
  </entry>
  
</feed>
